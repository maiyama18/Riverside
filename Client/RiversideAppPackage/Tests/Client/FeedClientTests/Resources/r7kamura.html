<!DOCTYPE html>
<!-- saved from url=(0021)https://r7kamura.com/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width"><meta name="color-scheme" content="light dark"><link rel="alternate" type="application/rss+xml" href="https://r7kamura.com/feed.xml"><link rel="search" type="application/opensearchdescription+xml" title="r7kamura.com" href="https://r7kamura.com/opensearch.xml"><title>r7kamura.com</title><link href="https://r7kamura.com/" rel="canonical"><meta name="description" content="日々の生活やプログラミングに関する情報を発信する、r7kamuraのウェブサイト"><meta name="og:description" content="日々の生活やプログラミングに関する情報を発信する、r7kamuraのウェブサイト"><meta name="og:title" content="r7kamura.com"><meta name="og:type" content="website"><meta name="og:url" content="https://r7kamura.com/"><meta name="og:image" content="https://r7kamura.com/default_og_image.jpg"><meta property="twitter:card" content="summary"><meta name="next-head-count" content="14"><link rel="preload" href="./r7kamura_files/fe9ea897df63fbe8.css" as="style"><link rel="stylesheet" href="./r7kamura_files/fe9ea897df63fbe8.css" data-n-g=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./r7kamura_files/polyfills-5cd94c89d3acac5f.js"></script><script src="./r7kamura_files/webpack-9b312e20a4e32339.js" defer=""></script><script src="./r7kamura_files/framework-a87821de553db91d.js" defer=""></script><script src="./r7kamura_files/main-b4364097422961ef.js" defer=""></script><script src="./r7kamura_files/_app-b1ef43ac02acbddc.js" defer=""></script><script src="./r7kamura_files/810-b352b69b9bff603e.js" defer=""></script><script src="./r7kamura_files/index-53af350b9a8b1ac5.js" defer=""></script><script src="./r7kamura_files/_buildManifest.js" defer=""></script><script src="./r7kamura_files/_ssgManifest.js" defer=""></script><script src="./r7kamura_files/_middlewareManifest.js" defer=""></script><link as="script" rel="prefetch" href="./r7kamura_files/[articleName]-8ca6a25b238725bc.js"></head><body class="vsc-initialized"><div id="__next"><div class="min-h-screen bg-gray-200 dark:bg-gray-900 dark:text-gray-100"><header class="bg-gray-50 dark:bg-gray-800"><nav class="container mx-auto max-w-2xl px-4 py-12"><p><a class="font-bold text-gray-900 visited:text-gray-900 dark:text-gray-300 dark:visited:text-gray-300" href="https://r7kamura.com/">r7kamura.com</a></p></nav></header><main class="bg-gray-50 dark:bg-gray-800"><div class="container mx-auto max-w-2xl px-4 py-12"><section><p>r7kamura.comは、日々の生活やプログラミングに関する情報を発信する、r7kamuraのウェブサイトです。</p></section><section class="mt-12"><ol class="flex flex-col gap-12"><li><time datetime="2023-12-29T00:00+0900" class="block text-[.8rem] text-gray-500 dark:text-gray-400">2023年12月29日</time><a href="https://r7kamura.com/articles/2023-12-29-vscode-ruby-light">vscode-ruby-light開発日記 - Prismパーサー導入編</a><p>vscode-ruby-lightの開発中に考えたことを書いていきます。</p></li><li><time datetime="2023-12-24T00:00+0900" class="block text-[.8rem] text-gray-500 dark:text-gray-400">2023年12月24日</time><a href="https://r7kamura.com/articles/2023-12-24-route53-to-cloudflare">ドメインをRoute53からCloudflareに移管</a><p>r7kamura.comドメインをAmazon Route53からCloudflareに移管したので、手順等を書き残しておきます。</p></li><li><time datetime="2023-12-23T00:00+0900" class="block text-[.8rem] text-gray-500 dark:text-gray-400">2023年12月23日</time><a href="https://r7kamura.com/articles/2023-12-23-vscode-ruby-light">vscode-ruby-light開発日記 - 初期版ふりかえり編</a><p>vscode-ruby-lightの開発中に考えたことを書いていきます。</p></li><li><time datetime="2023-12-15T00:00+0900" class="block text-[.8rem] text-gray-500 dark:text-gray-400">2023年12月15日</time><a href="https://r7kamura.com/articles/2023-12-15-npm-cache">npm ciのキャッシュ方式の検討</a><p>結論から言うと、node_modulesをキャッシュしてnpm ciの実行を省略するのが、多くの場合には有効そうです。</p></li><li><time datetime="2023-12-12T00:00+0900" class="block text-[.8rem] text-gray-500 dark:text-gray-400">2023年12月12日</time><a href="https://r7kamura.com/articles/2023-12-12-cable-management">デスク配線記</a><p>作業机の配線の記録をまとめておきます。</p></li><li><time datetime="2023-12-09T00:00+0900" class="block text-[.8rem] text-gray-500 dark:text-gray-400">2023年12月09日</time><a href="https://r7kamura.com/articles/2023-12-09-danbooru">家のダンボール全部抜く</a><p>重い腰を上げ、家のダンボールをまとめて資源回収に出した。</p></li><li><time datetime="2023-12-08T00:00+0900" class="block text-[.8rem] text-gray-500 dark:text-gray-400">2023年12月08日</time><a href="https://r7kamura.com/articles/2023-12-08-sesame">スマートロックの『SESAME 5』と『SESAME Touch Pro』が良い</a><p>SESAME 5とSESAME Touch Proを導入して、非常に満足しているという話。</p></li></ol><p class="mt-20"><a class="before:content-[&#39;»_&#39;]" href="https://r7kamura.com/articles">すべての記事一覧へ</a></p></section></div></main><footer class="container mx-auto max-w-2xl px-4 py-12 text-sm leading-loose"><nav><ul class="list-disc ml-4"><li><a class="text-gray-900 visited:text-gray-900 dark:text-gray-300 dark:visited:text-gray-300" href="https://r7kamura.com/">ホーム</a></li><li><a class="text-gray-900 visited:text-gray-900 dark:text-gray-300 dark:visited:text-gray-300" href="https://r7kamura.com/articles">記事一覧</a></li><li><a class="text-gray-900 visited:text-gray-900 dark:text-gray-300 dark:visited:text-gray-300" href="https://r7kamura.com/about">このサイトについて</a></li></ul></nav></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"articles":[{"date":"2023-12-29","name":"2023-12-29-vscode-ruby-light","slug":"vscode-ruby-light","body":"\n[vscode-ruby-light](https://github.com/r7kamura/vscode-ruby-light)の開発中に考えたことを書いていきます。今回は、内部で利用しているRuby用パーサーの[tree-sitter-ruby](https://github.com/tree-sitter/tree-sitter-ruby)から[Prism](https://github.com/ruby/prism/tree/main)への移行について書きます。\n\n## @ruby/prismパッケージの概観\n\nPrismは、JavaScriptからもその実装を利用できるよう、@ruby/prismという名前でnpmパッケージを公開しています。\n\n何が含まれているパッケージなのかというと、まずWASMバイナリという形でコンパイルされたPrismの実装と、それを便利に使うためのJavaScriptの実装、それからTypeScript向けの型定義ファイルが含まれています。これらはESModuleという形式に従ってモジュール化されています。またruby/prismのリポジトリ内に、JavaScript向けの簡単なドキュメントも含まれています。\n\nもちろん、本拡張でもこのnpmパッケージを利用しました。\n\n## CommonJSからESModuleへの移行\n\n本拡張に含まれるLanguage Serverの実装ではもともと、公式の雛形に従い、CommonJSが利用されていました。\n\n基本的に、CommonJSのモジュールからESModuleのモジュールは利用できません。@ruby/prismは前述した通りESModuleを採用しているので、今回を機にCommonJSからESModuleへ移行することにしました。\n\nとはいえ、基本的には等価な処理を実現できることが分かっているので、単純な変換作業が多いだけで、そこまで難しい変更ではありませんでした。要点を整理すると、以下の作業が必要でした。\n\n- package.jsonで、ESModuleを利用することを示す\n- tsconfig.jsonで、ESModule向けにコンパイルすることを示す\n- `import` でこれまで省略が許されていた拡張子を補う\n- `require` を利用している箇所を書き換える\n\n## VSCode拡張からのWASMの利用\n\n「WASMバイナリで実装が提供されている」って何？という話ですが、そんなに難しいものではありません。\n\n例えば本拡張のようにNode.jsから利用する場合、prism.wasmというファイルを `fs.readFileSync` で読み込んで、WASMを扱う上でのお決まりのパターンで初期化処理を書くと、便利に呼び出せる関数が取り出せるという感じです。\n\nこれはWASMバイナリ側の実装によりますが、標準入出力を行ったりメモリ割り当てを行ったりしたいという都合で、WASMバイナリの内部実装にはOSの機能を使うような処理が含まれている場合があります。そういった処理をWASMバイナリに含められるように、WASI (WebAssembly System Interface) という仕様があり、WASMバイナリの利用者側で初期化時にWASI互換のアダプタを用意してあげることになっています。勿論、そういった機能に依存していない実装であればこれは不要ですが、@ruby/prismの場合はこれが必要な実装になっています。\n\n一般的なNode.jsのランタイムであれば、特に労せずして簡単にWASI互換のアダプタを用意できるのですが、VSCode拡張のランタイムは少し特殊な環境で、これが利用できません。そこで今回は、WebブラウザからWASMバイナリを利用するときによく使われるWASI用のShim、[bjorn3/browser_wasi_shim](https://github.com/bjorn3/browser_wasi_shim)で代用することにしました。\n\n## TypeScriptからの@ruby/prismの利用\n\n今回はTypeScriptから@ruby/prismを利用することになりました。今回のような、Language Server Protocolや抽象構文木を扱うコードを書く場合は特に、型検査の恩恵を大きく受けられます。\n\nTypeScriptから@ruby/prismを利用する場合、TypeScript向けの型定義ファイルがパッケージの `types/*.d.ts` というパスに含まれているので、これを利用するだけで十分です。ただ、パッケージ側にニ点ほど問題があったので、それらに対処する必要がありました。\n\n一点目は、型定義の誤りです。Prismは元々C言語で開発されている訳なので、コードをある程度機械的に生成することでJavaScript向けのnpmパッケージを提供しています。Prismの生成するJavaScriptファイルには、JSDocという形式に則ったコメントで型注釈が記述されています。最近のTypeScriptコンパイラは、このJSDocの型注釈を利用して型定義ファイルを生成できるのですが、この型注釈にいくつか誤りがあったため、これを修正する必要がありました。\n\n- [Fix `Cannot find name 'Node'` error in types/visitor.d.ts by r7kamura · Pull Request #2107 · ruby/prism](https://github.com/ruby/prism/pull/2107)\n\n二点目は、型定義ファイルの配置場所です。細かい話をすっ飛ばして説明すると、`src/foo.js` というファイルに対して `src/foo.d.ts` というパスに型定義ファイルがあれば、TypeScriptコンパイラは `src/foo.js` を読み込もうとしている箇所で自動的にその型定義を検出してくれます。一方、実際には `types/*.d.ts` に型定義ファイルがあるので、ここでミスマッチが生じ、そのままでは型定義ファイルがないですよというエラーが出てしまいます。利用者側でTypeScriptコンパイラに対して適当な設定を追加すれば解決できるのですが、利用者に都度この設定を強制するのは大変だと思うので、一旦Issueを用意してより良い形を模索することにしました。\n\n- [More user-friendly type definition files structure for TypeScript · Issue #2114 · ruby/prism](https://github.com/ruby/prism/issues/2114)\n\n## パーサーを扱う箇所の書き換え\n\n本拡張は、以下の機能を提供しています。\n\n- Diagnostics\n    - RuboCopによる違反箇所の検出\n- Document Formatting\n    - RuboCopによる違反箇所の自動修正\n- Document Highlight\n    - カーソル位置のトークンに対応するトークンのハイライト\n- Document Symbol\n    - クラスやメソッド定義の検出 (アウトラインや検索で利用)\n- Selection Ranges\n    - Expand SelectionやShrink Selectionで拡縮される範囲の最適化\n- Others\n    - Rubyを検出するパターンの調整 (ファイルパスや拡張子、ファイルの内容等)\n    - 改行時のインデントルールの調整\n\nこの内、拡張内でRubyのパーサーが利用されているのは以下の3箇所です。これらの実装をPrismを利用するものに書き換えれば、tree-sitterからPrismへの移行完了です。\n\n- Document Highlight\n- Document Symbol\n- Selection Ranges\n\n## PrismとTree-sitterの比較\n\nPrismはTree-sitterと比べてどうなのかという話ですが、Prismの方が良い体験を提供できると感じています。\n\nいずれのパーサーを利用する場合でも、細かく手を加えていけば同様の処理を実現できるとは思います。それこそ、もし足りない部分があれば自前でパース処理を書けば良いですからね。そうなってくると、違いは実装コストに現れてきます。\n\n比較してみると、Tree-sitterのASTは字句解析上の表現、要するにトークン列にフォーカスしたASTの構造になっているのに対して、PrismのASTは意味解析上の表現にフォーカスしたASTの構造になっているように感じます。例えば、Tree-sitterでは `end` キーワードをAST上で1つの `EndKeywordNode` として扱っている一方、Prismではメソッド定義を表す `DefNode` というノードの中に `end` キーワードの位置情報が含まれている、といった具合です。\n\nこの違いは、どういった部分で効いてくるでしょうか。\n\n![](https://i.imgur.com/dJZJOtj.gif \"Selection Rangesの利用例\")\n\n例えば、Language Server ProtocolにSelection Rangesという仕組みがあります。これは、現在のカーソル位置から選択範囲を広げようとしたときに、どんな範囲の候補を提示すべきかを返す仕組みです。この仕組みを利用すると、エディタがExpand SelectionやShrink Selectionといった機能を実現できます。\n\nSelection Rangesに対応するためのLanguage Serverの内部実装としてはまず、与えられたソースコードとカーソルの位置情報を元に、カーソルに最も近い選択範囲の候補を見つけ、次にその範囲を内包する範囲を見つけ、更にその範囲を内包する範囲を見つけ……というように実装していきます。この実装において、選択範囲のデフォルトの候補としてAST上のノードを活用できます。エディタの利用者が選択したい範囲って、大体ASTのノードの単位ですからね。\n\n勿論、「引用符の内側を選択したあと、次は引用符を含む範囲を選択したい」といったような、AST上のノードの単位だけでは表現できない選択範囲もあるので、それらについては都度別途実装が必要になります。しかし、基本的にはASTのノードを利用すれば上手くいく場合が多いです。このとき、ASTのノードの単位が構文上の意味的な単位で構成されておらずガタガタしていると、選択範囲の候補として利用するには不自然な場合が増え、都度実装が必要になっていきます。\n\nPrismのASTは、こういった要件においてかなり自然に使える構造になっていたので、Tree-sitterと比べると実装が楽で、不具合が含まれる可能性も減るように感じました。\n\n## まとめ\n\n[vscode-ruby-light](https://github.com/r7kamura/vscode-ruby-light)で使っているRuby用パーサーを[tree-sitter-ruby](https://github.com/tree-sitter/tree-sitter-ruby)から[Prism](https://github.com/ruby/prism/tree/main)に移行したので、その過程で考えていたことについて書いてみました。\n\n[Ruby Light - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=r7kamura.vscode-ruby-light)に移行後の新しいバージョンを公開したので、興味がある人は試してみてください。移行直後でまだ全然試験運用されていないので、かなり不具合があるとは思います。多分ちょっと複雑なRubyのプログラムを開いた瞬間、右下にポップアップが出て、そのワークスペースでは拡張が一旦停止されるでしょう。気付き次第、折を見て改善していく予定です。\n\nそこまで難しい実装をしている訳ではないし、自分自身もTypeScriptもLSPもVSCodeもWASMもよく分からないまま雰囲気でやっている部分が多いので、何か開発に参加してみたいという人がいたら、是非手元で編集してPull Requestを送ってみてください。Mergeしたりしなかったりします。よろしくお願いします。\n","title":"vscode-ruby-light開発日記 - Prismパーサー導入編","description":"vscode-ruby-lightの開発中に考えたことを書いていきます。","imageUrl":"https://i.imgur.com/dJZJOtj.gif","renderedBody":"\u003cp\u003e\u003ca href=\"https://github.com/r7kamura/vscode-ruby-light\"\u003evscode-ruby-light\u003c/a\u003eの開発中に考えたことを書いていきます。今回は、内部で利用しているRuby用パーサーの\u003ca href=\"https://github.com/tree-sitter/tree-sitter-ruby\"\u003etree-sitter-ruby\u003c/a\u003eから\u003ca href=\"https://github.com/ruby/prism/tree/main\"\u003ePrism\u003c/a\u003eへの移行について書きます。\u003c/p\u003e\n\u003ch2\u003e@ruby/prismパッケージの概観\u003c/h2\u003e\n\u003cp\u003ePrismは、JavaScriptからもその実装を利用できるよう、@ruby/prismという名前でnpmパッケージを公開しています。\u003c/p\u003e\n\u003cp\u003e何が含まれているパッケージなのかというと、まずWASMバイナリという形でコンパイルされたPrismの実装と、それを便利に使うためのJavaScriptの実装、それからTypeScript向けの型定義ファイルが含まれています。これらはESModuleという形式に従ってモジュール化されています。またruby/prismのリポジトリ内に、JavaScript向けの簡単なドキュメントも含まれています。\u003c/p\u003e\n\u003cp\u003eもちろん、本拡張でもこのnpmパッケージを利用しました。\u003c/p\u003e\n\u003ch2\u003eCommonJSからESModuleへの移行\u003c/h2\u003e\n\u003cp\u003e本拡張に含まれるLanguage Serverの実装ではもともと、公式の雛形に従い、CommonJSが利用されていました。\u003c/p\u003e\n\u003cp\u003e基本的に、CommonJSのモジュールからESModuleのモジュールは利用できません。@ruby/prismは前述した通りESModuleを採用しているので、今回を機にCommonJSからESModuleへ移行することにしました。\u003c/p\u003e\n\u003cp\u003eとはいえ、基本的には等価な処理を実現できることが分かっているので、単純な変換作業が多いだけで、そこまで難しい変更ではありませんでした。要点を整理すると、以下の作業が必要でした。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epackage.jsonで、ESModuleを利用することを示す\u003c/li\u003e\n\u003cli\u003etsconfig.jsonで、ESModule向けにコンパイルすることを示す\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimport\u003c/code\u003e でこれまで省略が許されていた拡張子を補う\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequire\u003c/code\u003e を利用している箇所を書き換える\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eVSCode拡張からのWASMの利用\u003c/h2\u003e\n\u003cp\u003e「WASMバイナリで実装が提供されている」って何？という話ですが、そんなに難しいものではありません。\u003c/p\u003e\n\u003cp\u003e例えば本拡張のようにNode.jsから利用する場合、prism.wasmというファイルを \u003ccode\u003efs.readFileSync\u003c/code\u003e で読み込んで、WASMを扱う上でのお決まりのパターンで初期化処理を書くと、便利に呼び出せる関数が取り出せるという感じです。\u003c/p\u003e\n\u003cp\u003eこれはWASMバイナリ側の実装によりますが、標準入出力を行ったりメモリ割り当てを行ったりしたいという都合で、WASMバイナリの内部実装にはOSの機能を使うような処理が含まれている場合があります。そういった処理をWASMバイナリに含められるように、WASI (WebAssembly System Interface) という仕様があり、WASMバイナリの利用者側で初期化時にWASI互換のアダプタを用意してあげることになっています。勿論、そういった機能に依存していない実装であればこれは不要ですが、@ruby/prismの場合はこれが必要な実装になっています。\u003c/p\u003e\n\u003cp\u003e一般的なNode.jsのランタイムであれば、特に労せずして簡単にWASI互換のアダプタを用意できるのですが、VSCode拡張のランタイムは少し特殊な環境で、これが利用できません。そこで今回は、WebブラウザからWASMバイナリを利用するときによく使われるWASI用のShim、\u003ca href=\"https://github.com/bjorn3/browser_wasi_shim\"\u003ebjorn3/browser_wasi_shim\u003c/a\u003eで代用することにしました。\u003c/p\u003e\n\u003ch2\u003eTypeScriptからの@ruby/prismの利用\u003c/h2\u003e\n\u003cp\u003e今回はTypeScriptから@ruby/prismを利用することになりました。今回のような、Language Server Protocolや抽象構文木を扱うコードを書く場合は特に、型検査の恩恵を大きく受けられます。\u003c/p\u003e\n\u003cp\u003eTypeScriptから@ruby/prismを利用する場合、TypeScript向けの型定義ファイルがパッケージの \u003ccode\u003etypes/*.d.ts\u003c/code\u003e というパスに含まれているので、これを利用するだけで十分です。ただ、パッケージ側にニ点ほど問題があったので、それらに対処する必要がありました。\u003c/p\u003e\n\u003cp\u003e一点目は、型定義の誤りです。Prismは元々C言語で開発されている訳なので、コードをある程度機械的に生成することでJavaScript向けのnpmパッケージを提供しています。Prismの生成するJavaScriptファイルには、JSDocという形式に則ったコメントで型注釈が記述されています。最近のTypeScriptコンパイラは、このJSDocの型注釈を利用して型定義ファイルを生成できるのですが、この型注釈にいくつか誤りがあったため、これを修正する必要がありました。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ruby/prism/pull/2107\"\u003eFix \u003ccode\u003eCannot find name 'Node'\u003c/code\u003e error in types/visitor.d.ts by r7kamura · Pull Request #2107 · ruby/prism\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e二点目は、型定義ファイルの配置場所です。細かい話をすっ飛ばして説明すると、\u003ccode\u003esrc/foo.js\u003c/code\u003e というファイルに対して \u003ccode\u003esrc/foo.d.ts\u003c/code\u003e というパスに型定義ファイルがあれば、TypeScriptコンパイラは \u003ccode\u003esrc/foo.js\u003c/code\u003e を読み込もうとしている箇所で自動的にその型定義を検出してくれます。一方、実際には \u003ccode\u003etypes/*.d.ts\u003c/code\u003e に型定義ファイルがあるので、ここでミスマッチが生じ、そのままでは型定義ファイルがないですよというエラーが出てしまいます。利用者側でTypeScriptコンパイラに対して適当な設定を追加すれば解決できるのですが、利用者に都度この設定を強制するのは大変だと思うので、一旦Issueを用意してより良い形を模索することにしました。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ruby/prism/issues/2114\"\u003eMore user-friendly type definition files structure for TypeScript · Issue #2114 · ruby/prism\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eパーサーを扱う箇所の書き換え\u003c/h2\u003e\n\u003cp\u003e本拡張は、以下の機能を提供しています。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDiagnostics\n\u003cul\u003e\n\u003cli\u003eRuboCopによる違反箇所の検出\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDocument Formatting\n\u003cul\u003e\n\u003cli\u003eRuboCopによる違反箇所の自動修正\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDocument Highlight\n\u003cul\u003e\n\u003cli\u003eカーソル位置のトークンに対応するトークンのハイライト\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDocument Symbol\n\u003cul\u003e\n\u003cli\u003eクラスやメソッド定義の検出 (アウトラインや検索で利用)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSelection Ranges\n\u003cul\u003e\n\u003cli\u003eExpand SelectionやShrink Selectionで拡縮される範囲の最適化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eOthers\n\u003cul\u003e\n\u003cli\u003eRubyを検出するパターンの調整 (ファイルパスや拡張子、ファイルの内容等)\u003c/li\u003e\n\u003cli\u003e改行時のインデントルールの調整\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eこの内、拡張内でRubyのパーサーが利用されているのは以下の3箇所です。これらの実装をPrismを利用するものに書き換えれば、tree-sitterからPrismへの移行完了です。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDocument Highlight\u003c/li\u003e\n\u003cli\u003eDocument Symbol\u003c/li\u003e\n\u003cli\u003eSelection Ranges\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ePrismとTree-sitterの比較\u003c/h2\u003e\n\u003cp\u003ePrismはTree-sitterと比べてどうなのかという話ですが、Prismの方が良い体験を提供できると感じています。\u003c/p\u003e\n\u003cp\u003eいずれのパーサーを利用する場合でも、細かく手を加えていけば同様の処理を実現できるとは思います。それこそ、もし足りない部分があれば自前でパース処理を書けば良いですからね。そうなってくると、違いは実装コストに現れてきます。\u003c/p\u003e\n\u003cp\u003e比較してみると、Tree-sitterのASTは字句解析上の表現、要するにトークン列にフォーカスしたASTの構造になっているのに対して、PrismのASTは意味解析上の表現にフォーカスしたASTの構造になっているように感じます。例えば、Tree-sitterでは \u003ccode\u003eend\u003c/code\u003e キーワードをAST上で1つの \u003ccode\u003eEndKeywordNode\u003c/code\u003e として扱っている一方、Prismではメソッド定義を表す \u003ccode\u003eDefNode\u003c/code\u003e というノードの中に \u003ccode\u003eend\u003c/code\u003e キーワードの位置情報が含まれている、といった具合です。\u003c/p\u003e\n\u003cp\u003eこの違いは、どういった部分で効いてくるでしょうか。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/dJZJOtj.gif\" alt=\"\" title=\"Selection Rangesの利用例\"\u003e\u003cfigcaption\u003eSelection Rangesの利用例\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003e例えば、Language Server ProtocolにSelection Rangesという仕組みがあります。これは、現在のカーソル位置から選択範囲を広げようとしたときに、どんな範囲の候補を提示すべきかを返す仕組みです。この仕組みを利用すると、エディタがExpand SelectionやShrink Selectionといった機能を実現できます。\u003c/p\u003e\n\u003cp\u003eSelection Rangesに対応するためのLanguage Serverの内部実装としてはまず、与えられたソースコードとカーソルの位置情報を元に、カーソルに最も近い選択範囲の候補を見つけ、次にその範囲を内包する範囲を見つけ、更にその範囲を内包する範囲を見つけ……というように実装していきます。この実装において、選択範囲のデフォルトの候補としてAST上のノードを活用できます。エディタの利用者が選択したい範囲って、大体ASTのノードの単位ですからね。\u003c/p\u003e\n\u003cp\u003e勿論、「引用符の内側を選択したあと、次は引用符を含む範囲を選択したい」といったような、AST上のノードの単位だけでは表現できない選択範囲もあるので、それらについては都度別途実装が必要になります。しかし、基本的にはASTのノードを利用すれば上手くいく場合が多いです。このとき、ASTのノードの単位が構文上の意味的な単位で構成されておらずガタガタしていると、選択範囲の候補として利用するには不自然な場合が増え、都度実装が必要になっていきます。\u003c/p\u003e\n\u003cp\u003ePrismのASTは、こういった要件においてかなり自然に使える構造になっていたので、Tree-sitterと比べると実装が楽で、不具合が含まれる可能性も減るように感じました。\u003c/p\u003e\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/r7kamura/vscode-ruby-light\"\u003evscode-ruby-light\u003c/a\u003eで使っているRuby用パーサーを\u003ca href=\"https://github.com/tree-sitter/tree-sitter-ruby\"\u003etree-sitter-ruby\u003c/a\u003eから\u003ca href=\"https://github.com/ruby/prism/tree/main\"\u003ePrism\u003c/a\u003eに移行したので、その過程で考えていたことについて書いてみました。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://marketplace.visualstudio.com/items?itemName=r7kamura.vscode-ruby-light\"\u003eRuby Light - Visual Studio Marketplace\u003c/a\u003eに移行後の新しいバージョンを公開したので、興味がある人は試してみてください。移行直後でまだ全然試験運用されていないので、かなり不具合があるとは思います。多分ちょっと複雑なRubyのプログラムを開いた瞬間、右下にポップアップが出て、そのワークスペースでは拡張が一旦停止されるでしょう。気付き次第、折を見て改善していく予定です。\u003c/p\u003e\n\u003cp\u003eそこまで難しい実装をしている訳ではないし、自分自身もTypeScriptもLSPもVSCodeもWASMもよく分からないまま雰囲気でやっている部分が多いので、何か開発に参加してみたいという人がいたら、是非手元で編集してPull Requestを送ってみてください。Mergeしたりしなかったりします。よろしくお願いします。\u003c/p\u003e\n"},{"date":"2023-12-24","name":"2023-12-24-route53-to-cloudflare","slug":"route53-to-cloudflare","body":"\nr7kamura.comドメインをAmazon Route53からCloudflareに移管したので、手順等を書き残しておきます。\n\n## Cloudflareのアカウント作成\n\n自分の場合、2016年にアカウントを作成していたので、このアカウントを利用しました。無い場合はここで作成することになります。\n\n- \u003chttps://www.cloudflare.com/ja-jp/\u003e\n\nドメインの移管や維持にはお金が掛かります。ドメイン移管時に支払い情報の登録が必要になるので、ここで予めクレジットカードの情報等を設定しておくと事が円滑に進みます。\n\n## Cloudflareにドメイン名を登録\n\nCloudflareにログインし、管理画面右上の \"Add a site\" から、ドメイン名を登録してサイト情報を用意します。\n\nドメイン名を入力すると、このサイトに対して利用する料金プランを選択することになります。自分の場合、今回は無料のもので十分なので、Freeプランを選択しました。ここで、このドメインに今から設定すべきネームサーバーのアドレスが表示されます。今回は2つ表示されました。\n\n## CloudflareのSSL設定を調整\n\n今回移管するドメインは、GitHub Pagesでホスティングしてもらっている本ウェブサイトのために利用します。注意点として、GitHub PagesやVercel等でCloudflareを利用する場合、Cloudflare側で追加で必要な設定があります。Cloudflareにサイト (ドメイン) を登録した際、デフォルトではSSL/TLS encryption modeの設定が \"Flexible\" になります。GitHub PagesやVercelでは \"Flexible\" を利用するとリダイレクトループが発生してしまうため、今回はこれを \"Full\" または \"Full (strict)\" に変更する必要があります。\n\n詳しい情報については、[dns - How to fix ERR_TOO_MANY_REDIRECTS on custom github pages domain? - Stack Overflow](https://stackoverflow.com/questions/50145231/how-to-fix-err-too-many-redirects-on-custom-github-pages-domain) 等が参考になります。\n\n## Route53側のネームサーバーを変更\n\nRoute53の登録済みドメインの設定画面に行き、移管対象のドメインのネームサーバーを、前述のCloudflare側で発行されたものに変更します。\n\nこの設定により、このドメインにアクセスした際、Cloudflareのネームサーバーにアクセスされるようになります。Cloudflare側では、ドメイン登録時にRoute53から読み取ったDNSレコードが勝手に設定されているので、今回の用途のようなドメインであれば何も設定しなくてもこれまで通り上手く接続できるはずです。\n\n## Cloudflare側でネームサーバーをチェック\n\nRoute53側でネームサーバーの設定が完了したら、設定が完了したことを伝えるボタンをCloudflare側で押します。日本語UIだと「ネームサーバーをチェック」みたいなやつですね。ネームサーバーの反映にはしばらく掛かるので、これはその時点で成功しなくても問題ありません。\n\n## Route53側でドメイン移管リクエストを送信\n\n前準備として、Route53の登録済みドメインの設定画面に行き、もし対象ドメインの移管ロックがオンになっていたら、オフにします。自分の場合、元々オフでした。\n\nRoute53に、別のレジストラにドメインを移管するリクエストを送ります。ここで、移管先のCloudflareで発行される認証コードの入力を求められます。Cloudflare側でこの認証コードを取得できるので、これを持ってきて入力します。連絡先情報等の入力も求められます。\n\n## 移管の承認確認に対応\n\nRoute53側でドメイン移管リクエストを送信したら、ドメインの移管がはじまり、しばらく後に承認用のメールが届きます。このメールには、ドメイン移管の承認確認のためのURLが記載されているので、これを開いて承認作業を行います。これで、移管作業が完了します。\n\n## ホストゾーンの削除\n\n最後に、Route53にホストゾーンが存在していると課金され続けてしまうので、元々利用していたホストゾーンを削除しておきます。\n\n## 料金面\n\nr7kamura.comドメインの運用に必要な金額を整理してみます。\n\nRoute53の場合、この1年間では20.44USD (≒2,912円) 課金されていました。課金される要素は以下の通り。\n\n- ドメインの更新\n- DNSクエリ\n- ホストゾーン\n\nドメインの更新は、.comドメインの場合は年額13USD課金されます。\n\nDNSクエリに対しての課金は、以下の価格設定に対して月平均300,000クエリが発生していたので、月額0.12USD課金されます。\n\n\u003e $0.40 per 1,000,000 queries for the first 1 Billion queries\n\nホストゾーンに対しての課金は、以下の価格設定に対して、ドメインを1個管理するためにホストゾーンを1個設定する必要があるため、月額0.50USD課金されます。\n\n\u003e $0.50 per Hosted Zone for the first 25 Hosted Zones\n\nCloudflareの場合、年額8.03USD (≒1,142円) 課金される見込みです。課金される要素は以下の通り。\n\n- ドメインの更新\n\nドメインの更新は、.comドメインの場合は年額8.03USDです。\n","title":"ドメインをRoute53からCloudflareに移管","description":"r7kamura.comドメインをAmazon Route53からCloudflareに移管したので、手順等を書き残しておきます。","imageUrl":null,"renderedBody":"\u003cp\u003er7kamura.comドメインをAmazon Route53からCloudflareに移管したので、手順等を書き残しておきます。\u003c/p\u003e\n\u003ch2\u003eCloudflareのアカウント作成\u003c/h2\u003e\n\u003cp\u003e自分の場合、2016年にアカウントを作成していたので、このアカウントを利用しました。無い場合はここで作成することになります。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.cloudflare.com/ja-jp/\"\u003ehttps://www.cloudflare.com/ja-jp/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eドメインの移管や維持にはお金が掛かります。ドメイン移管時に支払い情報の登録が必要になるので、ここで予めクレジットカードの情報等を設定しておくと事が円滑に進みます。\u003c/p\u003e\n\u003ch2\u003eCloudflareにドメイン名を登録\u003c/h2\u003e\n\u003cp\u003eCloudflareにログインし、管理画面右上の \"Add a site\" から、ドメイン名を登録してサイト情報を用意します。\u003c/p\u003e\n\u003cp\u003eドメイン名を入力すると、このサイトに対して利用する料金プランを選択することになります。自分の場合、今回は無料のもので十分なので、Freeプランを選択しました。ここで、このドメインに今から設定すべきネームサーバーのアドレスが表示されます。今回は2つ表示されました。\u003c/p\u003e\n\u003ch2\u003eCloudflareのSSL設定を調整\u003c/h2\u003e\n\u003cp\u003e今回移管するドメインは、GitHub Pagesでホスティングしてもらっている本ウェブサイトのために利用します。注意点として、GitHub PagesやVercel等でCloudflareを利用する場合、Cloudflare側で追加で必要な設定があります。Cloudflareにサイト (ドメイン) を登録した際、デフォルトではSSL/TLS encryption modeの設定が \"Flexible\" になります。GitHub PagesやVercelでは \"Flexible\" を利用するとリダイレクトループが発生してしまうため、今回はこれを \"Full\" または \"Full (strict)\" に変更する必要があります。\u003c/p\u003e\n\u003cp\u003e詳しい情報については、\u003ca href=\"https://stackoverflow.com/questions/50145231/how-to-fix-err-too-many-redirects-on-custom-github-pages-domain\"\u003edns - How to fix ERR_TOO_MANY_REDIRECTS on custom github pages domain? - Stack Overflow\u003c/a\u003e 等が参考になります。\u003c/p\u003e\n\u003ch2\u003eRoute53側のネームサーバーを変更\u003c/h2\u003e\n\u003cp\u003eRoute53の登録済みドメインの設定画面に行き、移管対象のドメインのネームサーバーを、前述のCloudflare側で発行されたものに変更します。\u003c/p\u003e\n\u003cp\u003eこの設定により、このドメインにアクセスした際、Cloudflareのネームサーバーにアクセスされるようになります。Cloudflare側では、ドメイン登録時にRoute53から読み取ったDNSレコードが勝手に設定されているので、今回の用途のようなドメインであれば何も設定しなくてもこれまで通り上手く接続できるはずです。\u003c/p\u003e\n\u003ch2\u003eCloudflare側でネームサーバーをチェック\u003c/h2\u003e\n\u003cp\u003eRoute53側でネームサーバーの設定が完了したら、設定が完了したことを伝えるボタンをCloudflare側で押します。日本語UIだと「ネームサーバーをチェック」みたいなやつですね。ネームサーバーの反映にはしばらく掛かるので、これはその時点で成功しなくても問題ありません。\u003c/p\u003e\n\u003ch2\u003eRoute53側でドメイン移管リクエストを送信\u003c/h2\u003e\n\u003cp\u003e前準備として、Route53の登録済みドメインの設定画面に行き、もし対象ドメインの移管ロックがオンになっていたら、オフにします。自分の場合、元々オフでした。\u003c/p\u003e\n\u003cp\u003eRoute53に、別のレジストラにドメインを移管するリクエストを送ります。ここで、移管先のCloudflareで発行される認証コードの入力を求められます。Cloudflare側でこの認証コードを取得できるので、これを持ってきて入力します。連絡先情報等の入力も求められます。\u003c/p\u003e\n\u003ch2\u003e移管の承認確認に対応\u003c/h2\u003e\n\u003cp\u003eRoute53側でドメイン移管リクエストを送信したら、ドメインの移管がはじまり、しばらく後に承認用のメールが届きます。このメールには、ドメイン移管の承認確認のためのURLが記載されているので、これを開いて承認作業を行います。これで、移管作業が完了します。\u003c/p\u003e\n\u003ch2\u003eホストゾーンの削除\u003c/h2\u003e\n\u003cp\u003e最後に、Route53にホストゾーンが存在していると課金され続けてしまうので、元々利用していたホストゾーンを削除しておきます。\u003c/p\u003e\n\u003ch2\u003e料金面\u003c/h2\u003e\n\u003cp\u003er7kamura.comドメインの運用に必要な金額を整理してみます。\u003c/p\u003e\n\u003cp\u003eRoute53の場合、この1年間では20.44USD (≒2,912円) 課金されていました。課金される要素は以下の通り。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eドメインの更新\u003c/li\u003e\n\u003cli\u003eDNSクエリ\u003c/li\u003e\n\u003cli\u003eホストゾーン\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eドメインの更新は、.comドメインの場合は年額13USD課金されます。\u003c/p\u003e\n\u003cp\u003eDNSクエリに対しての課金は、以下の価格設定に対して月平均300,000クエリが発生していたので、月額0.12USD課金されます。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e$0.40 per 1,000,000 queries for the first 1 Billion queries\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eホストゾーンに対しての課金は、以下の価格設定に対して、ドメインを1個管理するためにホストゾーンを1個設定する必要があるため、月額0.50USD課金されます。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e$0.50 per Hosted Zone for the first 25 Hosted Zones\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCloudflareの場合、年額8.03USD (≒1,142円) 課金される見込みです。課金される要素は以下の通り。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eドメインの更新\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eドメインの更新は、.comドメインの場合は年額8.03USDです。\u003c/p\u003e\n"},{"date":"2023-12-23","name":"2023-12-23-vscode-ruby-light","slug":"vscode-ruby-light","body":"\n[vscode-ruby-light](https://github.com/r7kamura/vscode-ruby-light)の開発中に考えたことを書いていきます。今回は、2022年末に初期版を開発してから1年ほど経った2023年末時点でのふりかえりを行います。\n\n## vscode-ruby-lightとは\n\n1年ほど前に、[Ruby用VSCode拡張: vscode-ruby-light](https://r7kamura.com/articles/2022-08-16-vscode-ruby-light)という記事を書きました。要約すると、Rubyがインストールされていなくても使える、Rubyを書くのがちょっと便利になるVSCode拡張をつくってみているという話です。具体的には、シンタックスハイライトやトークンの選択など、VSCode標準の機能よりちょっと良い編集体験を提供しようという目的の拡張です。\n\nあまり真面目に開発している訳ではなく、VSCode拡張やLSPについての勉強も兼ね、ちょっとした趣味プロジェクトとして開発したりしなかったりしているというのが実情です。開発自体は1年ほど停滞していたのですが、この1年でRubyのパーサーやVSCode拡張を取り巻く情勢にも大きく変化があったので、これを機にまたしばらく開発を進めてみています。\n\n## Rubyのインストールの是非\n\n上述のVSCode拡張をつくってみた後、Rubyを必要としないことを利点とするのであれば、もしRubyや関連Gemをインストールしてもらえる場合はどのぐらい良い編集体験を提供できるのか、またその場合の導入や運用はどの程度大変なのか、ということをよく検証する必要があると考えました。\n\nそこで、新たに[rucoa](https://github.com/r7kamura/rucoa)というRuby用のLanguage Serverを提供するGemをつくり、[vscode-rucoa](https://github.com/r7kamura/vscode-rucoa)というVSCode拡張も用意して、Rubyを用いた開発現場で1年間ほど利用し、使い勝手を比較してみました。\n\n結果を整理すると、Rubyをインストールしてもらう形式の拡張の場合、まず以下の利点があると感じました。\n\n- Ruby製のパーサーを簡単に利用できるので、複雑な構文に対応できる\n- RuboCopの実行時に、外部コマンド経由でなくRubyのAPI経由でやり取りできる\n- 解析対象の言語で実装できるので、結果的に開発コストが低く済む\n\n一方で、以下の欠点があると感じました。\n\n- 導入に手間が掛かる\n- 複数人で開発するプロジェクトで導入しづらい\n- Dockerを利用した開発時に使いづらい\n\n結論すると、やはりRubyをインストールしない形式の拡張にも大きな需要があると感じました。\n\n## Ruby向けVSCode拡張を取り巻く環境の変化\n\nこの1年間ほどで、Ruby向けのVSCode拡張を取り巻く環境も幾らか変わりました。いい機会なので、関係がありそうな情報をここで紹介しておきます。\n\nRuby向けVSCode拡張としてデファクトスタンダードだった[vscode-ruby](https://github.com/rubyide/vscode-ruby)の開発が、元々それまでも停滞はしていたんですが、公式に完全停止されることとなり、リポジトリがアーカイブされ、マーケットプレイスにおいてもVSCode拡張に非推奨フラグが付くようになりました。\n\n代わりに、Shopifyが開発する[vscode-ruby-lsp](https://github.com/Shopify/vscode-ruby-lsp)が台頭し、vscode-rubyにおいてはこちらへの移行が推奨されるようになりました。この拡張は、rucoaと同じく別のGemでLanguage Serverを提供する形式になっており、Rubyに加えて[ruby-lsp](https://github.com/Shopify/ruby-lsp)というGemをインストールする必要があります。\n\nShopifyと言えば、Rubyにおける3rd Party製の静的型検査器である[sorbet](https://github.com/sorbet/sorbet)を導入していることでも有名で、ruby-lspにも解析対象のコードでsorbetが利用されている場合に有利な機能が幾つか実装されていたり、またruby-lspの開発自体にもsorbetが利用されています。この辺りの話題には、もしかしたら幾らか駆け引きがあるのかもしれませんね。\n\n他の話題として、[vscode-rdbg](https://github.com/ruby/vscode-rdbg)というものも登場し、便利な世の中になりました。Rubyの次世代デバッガー (要はブレイクポイントとかを設定したりできてちょっと豪華なデバッグができるやつ) として、[debug](https://github.com/ruby/debug)というGemがあるんですが、これをVSCodeから便利に使うためのVSCode拡張がvscode-rdbgという訳ですね。VSCodeはGUIから利用できるデバッグ機能向けインターフェースを豊富に備えているので、これとdebug gemの機能を組み合わせることで、より便利にRubyのデバッグができるようになります。\n\n他にVSCode拡張に関連しそうな話として、RuboCopに幾つか機能が増えました。1つ目がサーバーモードの追加で、RuboCopのデーモンプロセスをサーバーとして裏で起動しておくことで、それ以降のRuboCopの実行時に高速に起動できるようになりました。VSCode拡張から外部コマンド経由でRuboCopを実行する場合、ミリ秒単位の細かい起動時間が編集体験に効いてくるので、これはかなり重要な機能です。それから、RuboCopがLanguage Serverとしての機能を搭載するようになり、[vscode-rubocop](https://github.com/rubocop/vscode-rubocop)というVSCode拡張も登場しました。大LSP時代ですね。\n\n## Prismの登場\n\nRubyのパーサーとして、新たに[Prism](https://github.com/ruby/prism) (旧名:YARP) が登場しました。CRubyの内部で使うパーサーがどうなっていくかは今後色々あると思うんですが、少なくともRuby 3.3では、RubyからPrismのパーサーとしての機能を利用するAPIが利用できるようになるみたいですね。\n\n興味深い話として、Prismはいわゆるユニバーサルな使い方も意識してくれていて、WASM経由での利用方法も提供してくれています。これをVSCode拡張に利用できれば、Rubyを入れてもらわなくても複雑な構文に簡単に対応できるようになりそうです。\n\nという訳で、vscode-ruby-lightでは現在、内部で利用するパーサーをtree-sitter-rubyからPrismに変更するという活動を進めてみています。自分自身、WASM自体への知識やNode.jsからWASMを利用する方法なんかについての知識がまだまだ乏しいので、なかなか大変そうな活動ではありますが、勉強しながら楽しく進めていっています。\n\n- [Change parser from tree-sitter-ruby to prism by r7kamura · Pull Request #34 · r7kamura/vscode-ruby-light](https://github.com/r7kamura/vscode-ruby-light/pull/34)\n","title":"vscode-ruby-light開発日記 - 初期版ふりかえり編","description":"vscode-ruby-lightの開発中に考えたことを書いていきます。","imageUrl":null,"renderedBody":"\u003cp\u003e\u003ca href=\"https://github.com/r7kamura/vscode-ruby-light\"\u003evscode-ruby-light\u003c/a\u003eの開発中に考えたことを書いていきます。今回は、2022年末に初期版を開発してから1年ほど経った2023年末時点でのふりかえりを行います。\u003c/p\u003e\n\u003ch2\u003evscode-ruby-lightとは\u003c/h2\u003e\n\u003cp\u003e1年ほど前に、\u003ca href=\"https://r7kamura.com/articles/2022-08-16-vscode-ruby-light\"\u003eRuby用VSCode拡張: vscode-ruby-light\u003c/a\u003eという記事を書きました。要約すると、Rubyがインストールされていなくても使える、Rubyを書くのがちょっと便利になるVSCode拡張をつくってみているという話です。具体的には、シンタックスハイライトやトークンの選択など、VSCode標準の機能よりちょっと良い編集体験を提供しようという目的の拡張です。\u003c/p\u003e\n\u003cp\u003eあまり真面目に開発している訳ではなく、VSCode拡張やLSPについての勉強も兼ね、ちょっとした趣味プロジェクトとして開発したりしなかったりしているというのが実情です。開発自体は1年ほど停滞していたのですが、この1年でRubyのパーサーやVSCode拡張を取り巻く情勢にも大きく変化があったので、これを機にまたしばらく開発を進めてみています。\u003c/p\u003e\n\u003ch2\u003eRubyのインストールの是非\u003c/h2\u003e\n\u003cp\u003e上述のVSCode拡張をつくってみた後、Rubyを必要としないことを利点とするのであれば、もしRubyや関連Gemをインストールしてもらえる場合はどのぐらい良い編集体験を提供できるのか、またその場合の導入や運用はどの程度大変なのか、ということをよく検証する必要があると考えました。\u003c/p\u003e\n\u003cp\u003eそこで、新たに\u003ca href=\"https://github.com/r7kamura/rucoa\"\u003erucoa\u003c/a\u003eというRuby用のLanguage Serverを提供するGemをつくり、\u003ca href=\"https://github.com/r7kamura/vscode-rucoa\"\u003evscode-rucoa\u003c/a\u003eというVSCode拡張も用意して、Rubyを用いた開発現場で1年間ほど利用し、使い勝手を比較してみました。\u003c/p\u003e\n\u003cp\u003e結果を整理すると、Rubyをインストールしてもらう形式の拡張の場合、まず以下の利点があると感じました。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRuby製のパーサーを簡単に利用できるので、複雑な構文に対応できる\u003c/li\u003e\n\u003cli\u003eRuboCopの実行時に、外部コマンド経由でなくRubyのAPI経由でやり取りできる\u003c/li\u003e\n\u003cli\u003e解析対象の言語で実装できるので、結果的に開発コストが低く済む\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e一方で、以下の欠点があると感じました。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e導入に手間が掛かる\u003c/li\u003e\n\u003cli\u003e複数人で開発するプロジェクトで導入しづらい\u003c/li\u003e\n\u003cli\u003eDockerを利用した開発時に使いづらい\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e結論すると、やはりRubyをインストールしない形式の拡張にも大きな需要があると感じました。\u003c/p\u003e\n\u003ch2\u003eRuby向けVSCode拡張を取り巻く環境の変化\u003c/h2\u003e\n\u003cp\u003eこの1年間ほどで、Ruby向けのVSCode拡張を取り巻く環境も幾らか変わりました。いい機会なので、関係がありそうな情報をここで紹介しておきます。\u003c/p\u003e\n\u003cp\u003eRuby向けVSCode拡張としてデファクトスタンダードだった\u003ca href=\"https://github.com/rubyide/vscode-ruby\"\u003evscode-ruby\u003c/a\u003eの開発が、元々それまでも停滞はしていたんですが、公式に完全停止されることとなり、リポジトリがアーカイブされ、マーケットプレイスにおいてもVSCode拡張に非推奨フラグが付くようになりました。\u003c/p\u003e\n\u003cp\u003e代わりに、Shopifyが開発する\u003ca href=\"https://github.com/Shopify/vscode-ruby-lsp\"\u003evscode-ruby-lsp\u003c/a\u003eが台頭し、vscode-rubyにおいてはこちらへの移行が推奨されるようになりました。この拡張は、rucoaと同じく別のGemでLanguage Serverを提供する形式になっており、Rubyに加えて\u003ca href=\"https://github.com/Shopify/ruby-lsp\"\u003eruby-lsp\u003c/a\u003eというGemをインストールする必要があります。\u003c/p\u003e\n\u003cp\u003eShopifyと言えば、Rubyにおける3rd Party製の静的型検査器である\u003ca href=\"https://github.com/sorbet/sorbet\"\u003esorbet\u003c/a\u003eを導入していることでも有名で、ruby-lspにも解析対象のコードでsorbetが利用されている場合に有利な機能が幾つか実装されていたり、またruby-lspの開発自体にもsorbetが利用されています。この辺りの話題には、もしかしたら幾らか駆け引きがあるのかもしれませんね。\u003c/p\u003e\n\u003cp\u003e他の話題として、\u003ca href=\"https://github.com/ruby/vscode-rdbg\"\u003evscode-rdbg\u003c/a\u003eというものも登場し、便利な世の中になりました。Rubyの次世代デバッガー (要はブレイクポイントとかを設定したりできてちょっと豪華なデバッグができるやつ) として、\u003ca href=\"https://github.com/ruby/debug\"\u003edebug\u003c/a\u003eというGemがあるんですが、これをVSCodeから便利に使うためのVSCode拡張がvscode-rdbgという訳ですね。VSCodeはGUIから利用できるデバッグ機能向けインターフェースを豊富に備えているので、これとdebug gemの機能を組み合わせることで、より便利にRubyのデバッグができるようになります。\u003c/p\u003e\n\u003cp\u003e他にVSCode拡張に関連しそうな話として、RuboCopに幾つか機能が増えました。1つ目がサーバーモードの追加で、RuboCopのデーモンプロセスをサーバーとして裏で起動しておくことで、それ以降のRuboCopの実行時に高速に起動できるようになりました。VSCode拡張から外部コマンド経由でRuboCopを実行する場合、ミリ秒単位の細かい起動時間が編集体験に効いてくるので、これはかなり重要な機能です。それから、RuboCopがLanguage Serverとしての機能を搭載するようになり、\u003ca href=\"https://github.com/rubocop/vscode-rubocop\"\u003evscode-rubocop\u003c/a\u003eというVSCode拡張も登場しました。大LSP時代ですね。\u003c/p\u003e\n\u003ch2\u003ePrismの登場\u003c/h2\u003e\n\u003cp\u003eRubyのパーサーとして、新たに\u003ca href=\"https://github.com/ruby/prism\"\u003ePrism\u003c/a\u003e (旧名:YARP) が登場しました。CRubyの内部で使うパーサーがどうなっていくかは今後色々あると思うんですが、少なくともRuby 3.3では、RubyからPrismのパーサーとしての機能を利用するAPIが利用できるようになるみたいですね。\u003c/p\u003e\n\u003cp\u003e興味深い話として、Prismはいわゆるユニバーサルな使い方も意識してくれていて、WASM経由での利用方法も提供してくれています。これをVSCode拡張に利用できれば、Rubyを入れてもらわなくても複雑な構文に簡単に対応できるようになりそうです。\u003c/p\u003e\n\u003cp\u003eという訳で、vscode-ruby-lightでは現在、内部で利用するパーサーをtree-sitter-rubyからPrismに変更するという活動を進めてみています。自分自身、WASM自体への知識やNode.jsからWASMを利用する方法なんかについての知識がまだまだ乏しいので、なかなか大変そうな活動ではありますが、勉強しながら楽しく進めていっています。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/r7kamura/vscode-ruby-light/pull/34\"\u003eChange parser from tree-sitter-ruby to prism by r7kamura · Pull Request #34 · r7kamura/vscode-ruby-light\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"},{"date":"2023-12-15","name":"2023-12-15-npm-cache","slug":"npm-cache","body":"\n結論から言うと、node_modulesをキャッシュしてnpm ciの実行を省略するのが、多くの場合には有効そうです。\n\n## はじめに\n\nCIで `npm ci` を使うとき、実行時間短縮のためにキャッシュの利用を検討することになると思います。このとき、どのようにキャッシュするのが良いのでしょうか？\n\nよく知られているキャッシュ方式として、以下の二通りの方式があります。\n\n- ~/.npmをキャッシュする方式\n- node_modulesをキャッシュする方式\n\nそれぞれの違いについて、詳しく見てみましょう。\n\n## ~/.npmをキャッシュする方式\n\n`npm ci` を実行すると、POSIX系のOSではデフォルトで ~/.npm にキャッシュデータが書き込まれます。package-lock.json をキーにこのディレクトリをキャッシュしておくことで、次回以降の `npm ci` 実行時にこのキャッシュデータを利用しよう、というのがこの方式です。\n\n例えばGitHub Actionsの公式アクションである[actions/setup-node](https://github.com/actions/setup-node)では、この記事の執筆時点ではこの方式が推奨されており、これを補助する機能が実装されています。また、NPM公式ドキュメントの[npm-ci](https://docs.npmjs.com/cli/v10/commands/npm-ci)の項目でも、この方式の例が掲載されています。\n\n一方でこの方式の欠点として、キャッシュデータを利用していても、`npm ci` では色々な計算処理が行われるため、幾らか時間が掛かるという点が挙げられます。そのため、この方式は「意外と時間が掛かる」という感想になることが多いように思います。\n\n## node_modulesをキャッシュする方式\n\n`npm ci` の主な用途は、./node_modules 内に依存パッケージをインストールすることです。そこで、package-lock.json をキーにこのディレクトリをキャッシュしておくことで、次回以降の `npm ci` を省略しよう、というのがこの方式です。\n\nキャッシュが利用できる場合には `npm ci` が省略されるので、前述の方式と比べるとより短く済みます。一見すると全部この方式で良さそうですが、一体どんな欠点があるのでしょうか？話が長くなりそうなので先に結論を書いておくと、以下の二つの欠点があります。\n\n- Node.jsのバージョンをキャッシュキーに含めないと、バージョン変更時に困る\n- postinstall等の兼ね合いで上手くいかない場合がある\n\n例えば[actions/cache](https://github.com/actions/cache)のNPM利用者向けの説明箇所では、昔はnode_modulesをキャッシュする例が紹介されていました。しかし以下のIssueとPull Requestで、~/.npmをキャッシュする例に変更されました。\n\n- \u003chttps://github.com/actions/cache/issues/67\u003e\n- \u003chttps://github.com/actions/cache/pull/69\u003e\n\nこのときの変更理由を見てみると、この方式の欠点が見えてきそうです。\n\n\u003e This is generally not recommended: see [here](https://docs.npmjs.com/cli/ci.html#example), [here](https://stackoverflow.com/questions/42521884/should-i-have-travis-cache-node-modules-or-home-npm), [here](https://docs.microsoft.com/en-us/azure/devops/pipelines/caching/?view=azure-devops#nodejsnpm), etc. It also doesn't integrate well with npm's suggested CI workflow -- which is to cache `~/.npm` and use `npm ci` -- because `npm ci` always removes node_modules if it exists so caching it strictly slows down the build.\n\n説明の補足として、時代背景を考慮する必要があります。当時 `npm ci` はまだ比較的新しい機能であり、今ほど普及していませんでした。実際、この例でもそれまで `npm install` が利用されていました。そこで、`npm install` から `npm ci` に変更しながらキャッシュ方式も変更しようという、二点の変更が同時に提案された訳ですね。\n\nそれで、\"generally not recommended\" の拠り所として挙げられているリンク先を見てみると、「異なるバージョンのNode.js間で同じnode_modulesを再利用すると問題が起こる場合があるから、良くない」という話が書かれています。この問題は、Node.jsのバージョンをキャッシュキーに含めれば回避できそうです。\n\nまた、これについては特に言及を見かけませんでしたが、node_modulesをキャッシュすると上手くいかなくなる場合も稀に起こり得るはずです。\n\n\u003e `npm ci` の主な用途は、./node_modules 内に依存パッケージをインストールすることです。\n\nと前述しましたが、NPMのパッケージには、`install` や `postinstall` など、利用者がパッケージをインストールする際に実行されるスクリプトを登録できる機能があります。稀な例だとは思いますが、もしこれが高度に利用されていると、上手くいかなくなる可能性はありそうです。\n\n## GitHub Actionsでの設定例\n\n以上の点を踏まえ、ここではnode_modulesをキャッシュする方式の例として、GitHub Actionsでの単純な設定例を記述してみます。\n\n```yaml\n- uses: actions/setup-node@v3\n  with:\n    node-version-file: .node-version\n- id: cache-node-modules\n  uses: actions/cache@v3\n  with:\n    path: node_modules\n    key: node-modules-${{ runner.os }}-${{ hashFiles('.node-version') }}-${{ hashFiles('package-lock.json') }}\n    restore-keys: node-modules-${{ runner.os }}-${{ hashFiles('.node-version') }}-${{ hashFiles('package-lock.json') }}\n- if: steps.cache-node-modules.outputs.cache-hit != 'true'\n  run: npm ci\n```\n\nこの例では、キャッシュキーにNode.jsのバージョンを含め、キャッシュを見つけられなかった場合にのみ `npm ci` を実行しています。\n\n## おわり\n\n以上、`npm ci` の二つのキャッシュ方式について、それぞれの違いを見てみました。\n\n結果、可能な場合にはnode_modulesをキャッシュし、できればキャッシュキーにNode.jsのバージョンを含めるというのが、より実行時間の短縮をねらいたい場合には有効そうに思いました。`npm ci` のキャッシュ方式、皆さんも是非検討してみてください。\n","title":"npm ciのキャッシュ方式の検討","description":"結論から言うと、node_modulesをキャッシュしてnpm ciの実行を省略するのが、多くの場合には有効そうです。","imageUrl":null,"renderedBody":"\u003cp\u003e結論から言うと、node_modulesをキャッシュしてnpm ciの実行を省略するのが、多くの場合には有効そうです。\u003c/p\u003e\n\u003ch2\u003eはじめに\u003c/h2\u003e\n\u003cp\u003eCIで \u003ccode\u003enpm ci\u003c/code\u003e を使うとき、実行時間短縮のためにキャッシュの利用を検討することになると思います。このとき、どのようにキャッシュするのが良いのでしょうか？\u003c/p\u003e\n\u003cp\u003eよく知られているキャッシュ方式として、以下の二通りの方式があります。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e~/.npmをキャッシュする方式\u003c/li\u003e\n\u003cli\u003enode_modulesをキャッシュする方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eそれぞれの違いについて、詳しく見てみましょう。\u003c/p\u003e\n\u003ch2\u003e~/.npmをキャッシュする方式\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enpm ci\u003c/code\u003e を実行すると、POSIX系のOSではデフォルトで ~/.npm にキャッシュデータが書き込まれます。package-lock.json をキーにこのディレクトリをキャッシュしておくことで、次回以降の \u003ccode\u003enpm ci\u003c/code\u003e 実行時にこのキャッシュデータを利用しよう、というのがこの方式です。\u003c/p\u003e\n\u003cp\u003e例えばGitHub Actionsの公式アクションである\u003ca href=\"https://github.com/actions/setup-node\"\u003eactions/setup-node\u003c/a\u003eでは、この記事の執筆時点ではこの方式が推奨されており、これを補助する機能が実装されています。また、NPM公式ドキュメントの\u003ca href=\"https://docs.npmjs.com/cli/v10/commands/npm-ci\"\u003enpm-ci\u003c/a\u003eの項目でも、この方式の例が掲載されています。\u003c/p\u003e\n\u003cp\u003e一方でこの方式の欠点として、キャッシュデータを利用していても、\u003ccode\u003enpm ci\u003c/code\u003e では色々な計算処理が行われるため、幾らか時間が掛かるという点が挙げられます。そのため、この方式は「意外と時間が掛かる」という感想になることが多いように思います。\u003c/p\u003e\n\u003ch2\u003enode_modulesをキャッシュする方式\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enpm ci\u003c/code\u003e の主な用途は、./node_modules 内に依存パッケージをインストールすることです。そこで、package-lock.json をキーにこのディレクトリをキャッシュしておくことで、次回以降の \u003ccode\u003enpm ci\u003c/code\u003e を省略しよう、というのがこの方式です。\u003c/p\u003e\n\u003cp\u003eキャッシュが利用できる場合には \u003ccode\u003enpm ci\u003c/code\u003e が省略されるので、前述の方式と比べるとより短く済みます。一見すると全部この方式で良さそうですが、一体どんな欠点があるのでしょうか？話が長くなりそうなので先に結論を書いておくと、以下の二つの欠点があります。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNode.jsのバージョンをキャッシュキーに含めないと、バージョン変更時に困る\u003c/li\u003e\n\u003cli\u003epostinstall等の兼ね合いで上手くいかない場合がある\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e例えば\u003ca href=\"https://github.com/actions/cache\"\u003eactions/cache\u003c/a\u003eのNPM利用者向けの説明箇所では、昔はnode_modulesをキャッシュする例が紹介されていました。しかし以下のIssueとPull Requestで、~/.npmをキャッシュする例に変更されました。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/actions/cache/issues/67\"\u003ehttps://github.com/actions/cache/issues/67\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/actions/cache/pull/69\"\u003ehttps://github.com/actions/cache/pull/69\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eこのときの変更理由を見てみると、この方式の欠点が見えてきそうです。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis is generally not recommended: see \u003ca href=\"https://docs.npmjs.com/cli/ci.html#example\"\u003ehere\u003c/a\u003e, \u003ca href=\"https://stackoverflow.com/questions/42521884/should-i-have-travis-cache-node-modules-or-home-npm\"\u003ehere\u003c/a\u003e, \u003ca href=\"https://docs.microsoft.com/en-us/azure/devops/pipelines/caching/?view=azure-devops#nodejsnpm\"\u003ehere\u003c/a\u003e, etc. It also doesn't integrate well with npm's suggested CI workflow -- which is to cache \u003ccode\u003e~/.npm\u003c/code\u003e and use \u003ccode\u003enpm ci\u003c/code\u003e -- because \u003ccode\u003enpm ci\u003c/code\u003e always removes node_modules if it exists so caching it strictly slows down the build.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e説明の補足として、時代背景を考慮する必要があります。当時 \u003ccode\u003enpm ci\u003c/code\u003e はまだ比較的新しい機能であり、今ほど普及していませんでした。実際、この例でもそれまで \u003ccode\u003enpm install\u003c/code\u003e が利用されていました。そこで、\u003ccode\u003enpm install\u003c/code\u003e から \u003ccode\u003enpm ci\u003c/code\u003e に変更しながらキャッシュ方式も変更しようという、二点の変更が同時に提案された訳ですね。\u003c/p\u003e\n\u003cp\u003eそれで、\"generally not recommended\" の拠り所として挙げられているリンク先を見てみると、「異なるバージョンのNode.js間で同じnode_modulesを再利用すると問題が起こる場合があるから、良くない」という話が書かれています。この問題は、Node.jsのバージョンをキャッシュキーに含めれば回避できそうです。\u003c/p\u003e\n\u003cp\u003eまた、これについては特に言及を見かけませんでしたが、node_modulesをキャッシュすると上手くいかなくなる場合も稀に起こり得るはずです。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003enpm ci\u003c/code\u003e の主な用途は、./node_modules 内に依存パッケージをインストールすることです。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eと前述しましたが、NPMのパッケージには、\u003ccode\u003einstall\u003c/code\u003e や \u003ccode\u003epostinstall\u003c/code\u003e など、利用者がパッケージをインストールする際に実行されるスクリプトを登録できる機能があります。稀な例だとは思いますが、もしこれが高度に利用されていると、上手くいかなくなる可能性はありそうです。\u003c/p\u003e\n\u003ch2\u003eGitHub Actionsでの設定例\u003c/h2\u003e\n\u003cp\u003e以上の点を踏まえ、ここではnode_modulesをキャッシュする方式の例として、GitHub Actionsでの単純な設定例を記述してみます。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e- uses: actions/setup-node@v3\n  with:\n    node-version-file: .node-version\n- id: cache-node-modules\n  uses: actions/cache@v3\n  with:\n    path: node_modules\n    key: node-modules-${{ runner.os }}-${{ hashFiles('.node-version') }}-${{ hashFiles('package-lock.json') }}\n    restore-keys: node-modules-${{ runner.os }}-${{ hashFiles('.node-version') }}-${{ hashFiles('package-lock.json') }}\n- if: steps.cache-node-modules.outputs.cache-hit != 'true'\n  run: npm ci\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこの例では、キャッシュキーにNode.jsのバージョンを含め、キャッシュを見つけられなかった場合にのみ \u003ccode\u003enpm ci\u003c/code\u003e を実行しています。\u003c/p\u003e\n\u003ch2\u003eおわり\u003c/h2\u003e\n\u003cp\u003e以上、\u003ccode\u003enpm ci\u003c/code\u003e の二つのキャッシュ方式について、それぞれの違いを見てみました。\u003c/p\u003e\n\u003cp\u003e結果、可能な場合にはnode_modulesをキャッシュし、できればキャッシュキーにNode.jsのバージョンを含めるというのが、より実行時間の短縮をねらいたい場合には有効そうに思いました。\u003ccode\u003enpm ci\u003c/code\u003e のキャッシュ方式、皆さんも是非検討してみてください。\u003c/p\u003e\n"},{"date":"2023-12-12","name":"2023-12-12-cable-management","slug":"cable-management","body":"\n作業机の配線の記録をまとめておきます。\n\n![](https://i.imgur.com/JV0DACsh.jpg \"現在の様子\")\n\n## 2020\n\n2020年は牧歌的な時代で、子供の頃から使っていた机の上に、必要な機器を乱雑に並べていました。当時はゲームの録画や配信をはじめた頃だったので、それ以前と比べると、キャプチャーボードやオーディオインターフェースが増えていっていました。\n\n![](https://i.imgur.com/hDxuRn7h.jpg \"乱雑に積まれた機器達\")\n\n## 2021\n\n2021年には作業机を買い替えたり、はじめて自作PCを組んだりしました。この辺りでようやく、配線に真面目に向き合い始めました。この年には、天板下にクランプで取り付けられる、サンワサプライのケーブルトレーを導入しました。\n\n![](https://i.imgur.com/xMmOcXq.png \"電源ケーブルはカーペット下を通している\")\n\n![](https://i.imgur.com/hh0TeBxh.jpg \"あらゆる機器が詰め込まれたケーブルトレー\")\n\n![](https://i.imgur.com/9hwp7MNh.jpg \"電源タップはマグネットシートで設置\")\n\n![](https://i.imgur.com/0VctOAwh.jpg \"PC裏にはゲーム機\")\n\n## 2022\n\n引越しを済ませ、生活が落ち着いてきた頃合いで、半年間、朝6時から12時まで毎日作業配信をやってみました。これにより、マイクやカメラなどの機材が配線に加わりました。\n\n![](https://i.imgur.com/yQqe78jh.png \"バチバチに光らせて配信ソフトで遊んでいる\")\n\n毎日配信で自分の作業机の様子を映していると、流石に散らかっている部分が気になってきました。そこで夏頃、重い腰を上げ、机の位置を変えたり壁面照明を追加したり、机の位置を変更したりと、見栄えが良くなるよう試行錯誤を進めてみました。\n\n![](https://i.imgur.com/u2lPY19h.jpg \"いい感じに撮ったやつ 1\")\n\n![](https://i.imgur.com/9zt64XDh.jpg \"いい感じに撮ったやつ 2\")\n\nこの頃からオットマンを利用して脚を伸ばすようにしたことで、天板下のケーブルトレーが邪魔になることに気付きました。そこでケーブルトレーは廃止して、代わりにケーブルボックスを導入することにしました。PCの隣に配置して、あらゆる機器をここにぶち込んでいきます。\n\n![](https://i.imgur.com/5GyXWWNh.png \"やけに凝った配線図\")\n\n## 2023\n\nこれまでの配置は見栄えを優先するあまり、利便性や保守性に欠ける部分がありました。そこで、改めて配線を見直してみることにしました。\n\n![](https://i.imgur.com/JV0DACsh.jpg \"2023年の結論\")\n\n結果、現代のPCケースは作業机の右奥への設置が想定されていることから、PCの更に右奥側にケーブルボックスを置き、モニターアームやマイクアームもその付近から生やし、机の右奥で配線をまとめるのが最適だと結論付けました。配線距離を極力短くまとめることで、そもそもの配線の必要量を減らしつつ、発生するケーブルは全て箱にぶち込もうという考えです。天板下にまとめるのと比較すると、設置要件が緩く、メンテも簡単です。\n\nスマホやコントローラー、イヤホンなどの無線機器の充電用に、補助的に左側の棚にも電源系統を1つ用意し、こちらにもケーブルボックスを置いてみることにしました。こちらはあくまで補助で、最悪いつ電源が落ちても問題が無い機器類と位置付けています。設置要件的に大変そうであれば、これらの充電機器はPC付近にまとめても良いかも。\n\n![](https://i.imgur.com/r22AyJ6h.jpg \"電源ケーブルを脚に這わせている\")\n\n机には右下側から電源ケーブル1本だけを引き入れ、電源タップにケーブルスリーブを纏わせた上で、PC裏のケーブルボックスまで繋いでいます。有線LANケーブルを引きたい場合は、ここで一緒にまとめるのが良いですね。ケーブルがまるで存在しないのも寂しいし、自分はこの太い電源ケーブルが繋がっているところが気に入っているので、一部のケーブルはあえて見せておくようにしようと思っています。キーボードのケーブルなんかもその1つです。\n\nケーブルを這わせるためにネジ止めだとか両面テープだとかで天板に何かを固定するのは、いじるのもだるいしやり直しも効きづらいので、できれば使いたくありません。その点で、磁力で机の脚にケーブルを固定できるPREDUCTSのマグネットケーブルホルダーは重宝しました。たまにやってくるルンバも心なしか喜んでいるように見えます。\n\n![](https://i.imgur.com/FdZWE2Ch.jpg \"PC背面の様子\")\n\nモニターとPCとの間には、電源ケーブルと映像用のケーブルがそれぞれ1本ずつ必要なので、これらもケーブルスリーブでまとめています。JOTOのケーブルスリーブは質感が良く、値段や長さの点でもケーブルスリーブ界の中では比較的使いやすかったです。作業中の仮止めや細かい部分の結束では、使い捨ての面ファスナーで結束できるサンワサプライのマジックバンドが重宝しました。\n\n## おわり\n\n以上、2020年から2023年までの作業机の配線の記録でした。他人の作業環境の変遷やこだわり、考え方等を知るのが好きなので、自分で読みたい記事を書いてみました。配線整理、皆さんも是非やってみてください。\n\n## 追記\n\n質問をいただいたので、利用している機器等の商品ページへのリンクを載せておきます。\n\n- ケーブルボックス [山崎実業 ケーブルボックス](https://www.amazon.co.jp/dp/B0846DPNPP)\n- ケーブルトレー [サンワサプライ ケーブルトレー](https://www.amazon.co.jp/dp/B01N6B5ST9)\n- ケーブルスリーブ [JOTO ケーブルスリーブ](https://www.amazon.co.jp/dp/B088JTYSGX)\n- ケーブルバンド [サンワサプライ マジックバンド](https://www.amazon.co.jp/dp/B09ZV34326)\n- ケーブルホルダー [PREDUCTS マグネットケーブルホルダー](https://preducts.jp/products/magnet-cable-holder)\n- 電源タップ [エレコム 電源タップ](https://www.amazon.co.jp/dp/B01NH5C9I3)\n- キーボード用USBケーブル [GunMjo Pro カスタムコイルケーブル](https://www.amazon.co.jp/dp/B09F5T7LTQ)\n- モニター上 [Dell ALIENWARE AW3821DW](https://www.amazon.co.jp/dp/B08P49Z6BX)\n- モニター下 [LG UltraGear 45GR95QE-B](https://www.amazon.co.jp/dp/B0BWMJ6XL2)\n- モニターアーム [エルゴトロン LX デュアル ロングポール](https://www.amazon.co.jp/dp/B07514G4ZL)\n- マイクアーム1 [Logicool G Blue Compass](https://www.amazon.co.jp/dp/B0822PPK7P?th=1)\n- マイクアーム2 [Elgato Wave Mic Arm LP](https://www.amazon.co.jp/dp/B0CDWRJ6LB)\n- 机 [かなでもの THE TABLE](https://kanademono.design/collections/standard-size-table/products/tbl-k03-bk?variant=32465592254526)\n- 椅子 [EKORNES ストレスレストーキョー](https://www.amazon.co.jp/dp/B08B3S2SNZ)\n- 間接照明1 [Nanoleaf Lines](https://www.amazon.co.jp/dp/B09MS3359S)\n- 間接照明2 [Philips Hue ライトリボン](https://www.amazon.co.jp/dp/B08CZKKPH1)\n","title":"デスク配線記","description":"作業机の配線の記録をまとめておきます。","imageUrl":"https://i.imgur.com/JV0DACsh.jpg","renderedBody":"\u003cp\u003e作業机の配線の記録をまとめておきます。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/JV0DACsh.jpg\" alt=\"\" title=\"現在の様子\"\u003e\u003cfigcaption\u003e現在の様子\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2\u003e2020\u003c/h2\u003e\n\u003cp\u003e2020年は牧歌的な時代で、子供の頃から使っていた机の上に、必要な機器を乱雑に並べていました。当時はゲームの録画や配信をはじめた頃だったので、それ以前と比べると、キャプチャーボードやオーディオインターフェースが増えていっていました。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/hDxuRn7h.jpg\" alt=\"\" title=\"乱雑に積まれた機器達\"\u003e\u003cfigcaption\u003e乱雑に積まれた機器達\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2\u003e2021\u003c/h2\u003e\n\u003cp\u003e2021年には作業机を買い替えたり、はじめて自作PCを組んだりしました。この辺りでようやく、配線に真面目に向き合い始めました。この年には、天板下にクランプで取り付けられる、サンワサプライのケーブルトレーを導入しました。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/xMmOcXq.png\" alt=\"\" title=\"電源ケーブルはカーペット下を通している\"\u003e\u003cfigcaption\u003e電源ケーブルはカーペット下を通している\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/hh0TeBxh.jpg\" alt=\"\" title=\"あらゆる機器が詰め込まれたケーブルトレー\"\u003e\u003cfigcaption\u003eあらゆる機器が詰め込まれたケーブルトレー\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/9hwp7MNh.jpg\" alt=\"\" title=\"電源タップはマグネットシートで設置\"\u003e\u003cfigcaption\u003e電源タップはマグネットシートで設置\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/0VctOAwh.jpg\" alt=\"\" title=\"PC裏にはゲーム機\"\u003e\u003cfigcaption\u003ePC裏にはゲーム機\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2\u003e2022\u003c/h2\u003e\n\u003cp\u003e引越しを済ませ、生活が落ち着いてきた頃合いで、半年間、朝6時から12時まで毎日作業配信をやってみました。これにより、マイクやカメラなどの機材が配線に加わりました。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/yQqe78jh.png\" alt=\"\" title=\"バチバチに光らせて配信ソフトで遊んでいる\"\u003e\u003cfigcaption\u003eバチバチに光らせて配信ソフトで遊んでいる\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003e毎日配信で自分の作業机の様子を映していると、流石に散らかっている部分が気になってきました。そこで夏頃、重い腰を上げ、机の位置を変えたり壁面照明を追加したり、机の位置を変更したりと、見栄えが良くなるよう試行錯誤を進めてみました。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/u2lPY19h.jpg\" alt=\"\" title=\"いい感じに撮ったやつ 1\"\u003e\u003cfigcaption\u003eいい感じに撮ったやつ 1\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/9zt64XDh.jpg\" alt=\"\" title=\"いい感じに撮ったやつ 2\"\u003e\u003cfigcaption\u003eいい感じに撮ったやつ 2\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eこの頃からオットマンを利用して脚を伸ばすようにしたことで、天板下のケーブルトレーが邪魔になることに気付きました。そこでケーブルトレーは廃止して、代わりにケーブルボックスを導入することにしました。PCの隣に配置して、あらゆる機器をここにぶち込んでいきます。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/5GyXWWNh.png\" alt=\"\" title=\"やけに凝った配線図\"\u003e\u003cfigcaption\u003eやけに凝った配線図\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2\u003e2023\u003c/h2\u003e\n\u003cp\u003eこれまでの配置は見栄えを優先するあまり、利便性や保守性に欠ける部分がありました。そこで、改めて配線を見直してみることにしました。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/JV0DACsh.jpg\" alt=\"\" title=\"2023年の結論\"\u003e\u003cfigcaption\u003e2023年の結論\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003e結果、現代のPCケースは作業机の右奥への設置が想定されていることから、PCの更に右奥側にケーブルボックスを置き、モニターアームやマイクアームもその付近から生やし、机の右奥で配線をまとめるのが最適だと結論付けました。配線距離を極力短くまとめることで、そもそもの配線の必要量を減らしつつ、発生するケーブルは全て箱にぶち込もうという考えです。天板下にまとめるのと比較すると、設置要件が緩く、メンテも簡単です。\u003c/p\u003e\n\u003cp\u003eスマホやコントローラー、イヤホンなどの無線機器の充電用に、補助的に左側の棚にも電源系統を1つ用意し、こちらにもケーブルボックスを置いてみることにしました。こちらはあくまで補助で、最悪いつ電源が落ちても問題が無い機器類と位置付けています。設置要件的に大変そうであれば、これらの充電機器はPC付近にまとめても良いかも。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/r22AyJ6h.jpg\" alt=\"\" title=\"電源ケーブルを脚に這わせている\"\u003e\u003cfigcaption\u003e電源ケーブルを脚に這わせている\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003e机には右下側から電源ケーブル1本だけを引き入れ、電源タップにケーブルスリーブを纏わせた上で、PC裏のケーブルボックスまで繋いでいます。有線LANケーブルを引きたい場合は、ここで一緒にまとめるのが良いですね。ケーブルがまるで存在しないのも寂しいし、自分はこの太い電源ケーブルが繋がっているところが気に入っているので、一部のケーブルはあえて見せておくようにしようと思っています。キーボードのケーブルなんかもその1つです。\u003c/p\u003e\n\u003cp\u003eケーブルを這わせるためにネジ止めだとか両面テープだとかで天板に何かを固定するのは、いじるのもだるいしやり直しも効きづらいので、できれば使いたくありません。その点で、磁力で机の脚にケーブルを固定できるPREDUCTSのマグネットケーブルホルダーは重宝しました。たまにやってくるルンバも心なしか喜んでいるように見えます。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/FdZWE2Ch.jpg\" alt=\"\" title=\"PC背面の様子\"\u003e\u003cfigcaption\u003ePC背面の様子\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eモニターとPCとの間には、電源ケーブルと映像用のケーブルがそれぞれ1本ずつ必要なので、これらもケーブルスリーブでまとめています。JOTOのケーブルスリーブは質感が良く、値段や長さの点でもケーブルスリーブ界の中では比較的使いやすかったです。作業中の仮止めや細かい部分の結束では、使い捨ての面ファスナーで結束できるサンワサプライのマジックバンドが重宝しました。\u003c/p\u003e\n\u003ch2\u003eおわり\u003c/h2\u003e\n\u003cp\u003e以上、2020年から2023年までの作業机の配線の記録でした。他人の作業環境の変遷やこだわり、考え方等を知るのが好きなので、自分で読みたい記事を書いてみました。配線整理、皆さんも是非やってみてください。\u003c/p\u003e\n\u003ch2\u003e追記\u003c/h2\u003e\n\u003cp\u003e質問をいただいたので、利用している機器等の商品ページへのリンクを載せておきます。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eケーブルボックス \u003ca href=\"https://www.amazon.co.jp/dp/B0846DPNPP?tag=r7kamuracom-22\"\u003e山崎実業 ケーブルボックス\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eケーブルトレー \u003ca href=\"https://www.amazon.co.jp/dp/B01N6B5ST9?tag=r7kamuracom-22\"\u003eサンワサプライ ケーブルトレー\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eケーブルスリーブ \u003ca href=\"https://www.amazon.co.jp/dp/B088JTYSGX?tag=r7kamuracom-22\"\u003eJOTO ケーブルスリーブ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eケーブルバンド \u003ca href=\"https://www.amazon.co.jp/dp/B09ZV34326?tag=r7kamuracom-22\"\u003eサンワサプライ マジックバンド\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eケーブルホルダー \u003ca href=\"https://preducts.jp/products/magnet-cable-holder\"\u003ePREDUCTS マグネットケーブルホルダー\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e電源タップ \u003ca href=\"https://www.amazon.co.jp/dp/B01NH5C9I3?tag=r7kamuracom-22\"\u003eエレコム 電源タップ\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eキーボード用USBケーブル \u003ca href=\"https://www.amazon.co.jp/dp/B09F5T7LTQ?tag=r7kamuracom-22\"\u003eGunMjo Pro カスタムコイルケーブル\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eモニター上 \u003ca href=\"https://www.amazon.co.jp/dp/B08P49Z6BX?tag=r7kamuracom-22\"\u003eDell ALIENWARE AW3821DW\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eモニター下 \u003ca href=\"https://www.amazon.co.jp/dp/B0BWMJ6XL2?tag=r7kamuracom-22\"\u003eLG UltraGear 45GR95QE-B\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eモニターアーム \u003ca href=\"https://www.amazon.co.jp/dp/B07514G4ZL?tag=r7kamuracom-22\"\u003eエルゴトロン LX デュアル ロングポール\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eマイクアーム1 \u003ca href=\"https://www.amazon.co.jp/dp/B0822PPK7P?th=1?tag=r7kamuracom-22\"\u003eLogicool G Blue Compass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eマイクアーム2 \u003ca href=\"https://www.amazon.co.jp/dp/B0CDWRJ6LB?tag=r7kamuracom-22\"\u003eElgato Wave Mic Arm LP\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e机 \u003ca href=\"https://kanademono.design/collections/standard-size-table/products/tbl-k03-bk?variant=32465592254526\"\u003eかなでもの THE TABLE\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e椅子 \u003ca href=\"https://www.amazon.co.jp/dp/B08B3S2SNZ?tag=r7kamuracom-22\"\u003eEKORNES ストレスレストーキョー\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e間接照明1 \u003ca href=\"https://www.amazon.co.jp/dp/B09MS3359S?tag=r7kamuracom-22\"\u003eNanoleaf Lines\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e間接照明2 \u003ca href=\"https://www.amazon.co.jp/dp/B08CZKKPH1?tag=r7kamuracom-22\"\u003ePhilips Hue ライトリボン\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"},{"date":"2023-12-09","name":"2023-12-09-danbooru","slug":"danbooru","body":"\n重い腰を上げ、家のダンボールをまとめて資源回収に出した。\n\n![](https://i.imgur.com/nowHy0Gh.jpg \"まとめたダンボールの一部\")\n\nダンボールをまとめるため、今回から山善のハンディラップを導入して、これが非常に便利だった。適当な単位で重ねたダンボールを正座した状態で太ももの間に挟んで立てて、ハンディラップで3周ほどぐるっと巻くと綺麗にまとまる。\n\n- [Amazon｜[山善] ハンディラップ セット品 幅10cm×150m巻 ストレッチ フィルム くるット セット(本体1個+交換用ラップ3個) HW-150/HWR-150｜新聞・雑誌ストッカー オンライン通販](https://www.amazon.co.jp/dp/B06XW4QHNS?th=1)\n\nダンボールストッカーがあると、まとめるのが更に楽になるのかもしれない。今のところうちでは、引越用に使った大きなダンボールにそれ以外のダンボールを突っ込んでストックしていくという運用でやっている。\n\n![](https://i.imgur.com/L4wyAyZh.jpg \"100年ぶりに土間の床が見えた\")\n\nハンディラップ使っていいのかどうかについて。元々、うちのゴミ収集所のゴミの捨て方的なガイドブックには、ダンボールはビニール紐でまとめるよう説明されていた。念のため、事前に収集所の管理人に聞いてみたところ、ハンディラップでも問題無いとの回答を得られた。\n\n素人がビニール紐でフニャフニャに縛ろうとして崩壊しかけになってるよりは、ハンディラップで綺麗にまとまってる方が収集しやすいと思うので、そんなに断られることはないように思うけど、収集場所によって判断基準は異なると思うので、事前に確認はしておいた方が良いかもしれない。\n","title":"家のダンボール全部抜く","description":"重い腰を上げ、家のダンボールをまとめて資源回収に出した。","imageUrl":"https://i.imgur.com/nowHy0Gh.jpg","renderedBody":"\u003cp\u003e重い腰を上げ、家のダンボールをまとめて資源回収に出した。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/nowHy0Gh.jpg\" alt=\"\" title=\"まとめたダンボールの一部\"\u003e\u003cfigcaption\u003eまとめたダンボールの一部\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eダンボールをまとめるため、今回から山善のハンディラップを導入して、これが非常に便利だった。適当な単位で重ねたダンボールを正座した状態で太ももの間に挟んで立てて、ハンディラップで3周ほどぐるっと巻くと綺麗にまとまる。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.amazon.co.jp/dp/B06XW4QHNS?th=1?tag=r7kamuracom-22\"\u003eAmazon｜[山善] ハンディラップ セット品 幅10cm×150m巻 ストレッチ フィルム くるット セット(本体1個+交換用ラップ3個) HW-150/HWR-150｜新聞・雑誌ストッカー オンライン通販\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eダンボールストッカーがあると、まとめるのが更に楽になるのかもしれない。今のところうちでは、引越用に使った大きなダンボールにそれ以外のダンボールを突っ込んでストックしていくという運用でやっている。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/L4wyAyZh.jpg\" alt=\"\" title=\"100年ぶりに土間の床が見えた\"\u003e\u003cfigcaption\u003e100年ぶりに土間の床が見えた\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eハンディラップ使っていいのかどうかについて。元々、うちのゴミ収集所のゴミの捨て方的なガイドブックには、ダンボールはビニール紐でまとめるよう説明されていた。念のため、事前に収集所の管理人に聞いてみたところ、ハンディラップでも問題無いとの回答を得られた。\u003c/p\u003e\n\u003cp\u003e素人がビニール紐でフニャフニャに縛ろうとして崩壊しかけになってるよりは、ハンディラップで綺麗にまとまってる方が収集しやすいと思うので、そんなに断られることはないように思うけど、収集場所によって判断基準は異なると思うので、事前に確認はしておいた方が良いかもしれない。\u003c/p\u003e\n"},{"date":"2023-12-08","name":"2023-12-08-sesame","slug":"sesame","body":"\n[SESAME 5](https://www.amazon.co.jp/dp/B0C22W4Y5H)と[SESAME Touch Pro](https://www.amazon.co.jp/dp/B0C232GL4Q)を導入して、非常に満足しているという話。\n\n![](https://i.imgur.com/h8mqrdqh.jpg \"一回取り外してメンテ中のSESAME Touch Proの様子\")\n\n## Qrio Lock\n\n2019年12月から2023年9月までは、Qrio Lockというスマートロックを使っていた。2019年の時点では、スマートロックの導入として非常に良い選択肢だったと思っているけれど、この製品には幾つかの不満も抱えていた。\n\nQrio Lockの解錠の方法として、ジオフェンス (要はスマホが近付いたら位置情報を元に自動的に解錠するやつ) を使うか、あるいはそれが効かない場合にはiPhoneのアプリを使っていた。\n\nジオフェンスで解錠が完全に自動化されて最高かと思いきや、この解錠方法に大きな不満があった。この機能は玄関から大体100mぐらい離れた場所に移動して帰ってきた場合にしか作動しないので、例えばゴミ捨てに少しだけ外に出た場合には動作しない。また、動作するまでに数秒から十数秒かかることや、上手く検知されず解錠されない場合があったりして、玄関の前でしばらく立ち尽くすことが多く、結局それを嫌ってiPhoneのアプリを開いて解錠するということが増えていた。\n\nいい大人がマンションの玄関の前で立ち尽くしている構図って、なんだか寂しいものがありますよね。万が一他の住民がたまたまそのタイミングで通りがかったときに備えて、私はUberの配達員のフリをする心構えをしていましたが、結局一度もその機会は訪れませんでした。\n\n## SESAME 5 と SESAME Touch Pro\n\n2023年6月、SESAME 5とSESAME Touch Proが新たに発売されるということを知り、少し調べた結果以下の機能があることが分かり、購入に踏み切った。\n\n- 指紋認証で解錠できる\n- NFC端末で解錠できる\n- アプリで解錠できる\n- パスコードで解錠できる\n\n指紋認証。これが一番利用頻度が高くて、普段解錠するのに使っている。100個まで登録できるので、指が多くても安心。\n\nNFC端末。要するにスマホを近付けたら解錠できますよというやつ。これは冬場に解錠するのに使っている。なぜなら、冬場の外出時は常に手袋をしているから。iPhoneをNFC端末として登録している。エクスプレスモード (iPhoneのロックを解除しなくてもICカード機能が使えるやつ) にも対応しているけど、iPhoneを盗られたときに侵入されるリスクがあるので、今のところエクスプレスモードは解錠には使っていない。\n\nアプリでの解錠。客人が帰るとき、基本的に自分より相手が先に玄関側に辿り着いてしまうので、靴を履いたりしている間にスマホで解錠している。勿論、解錠の手間を減らしてあげたいという配慮でもあるのだけど、それが主な目的ではない。スマートロックって両面テープで貼り付けているだけなので、施錠されている状態で事情を知らず力強く玄関が押されると、外れてしまったり、最悪壊れたりしてしまうことがあるので、それを防止したいという背景がある。解錠時にモーター音がある程度鳴る設計だと、「ああ何らかの仕組みで解錠されたんだな」ということが相手にも分かるので、この辺は完全に静音であるより、ある程度音があった方が都合が良かったりする。アプリでの解錠は、SESAME Touch Proの電池が切れたり動作不良を起こしたときのための緊急手段としても使っている。\n\nパスコード。文字盤で適当な数字を入力したら解錠できるやつ。極稀にトリッキーな用途で使っている。事前に一時的なパスコードを幾つか登録しておいて、家族や親しい友達が先に自宅に着いてしまったときにパスコードを連絡して先に入っておいてもらう、といった使い方。100個まで登録できるので、友達が多くても安心。\n\n## 設置と脱着\n\nSESAME 5とSESAME Touch Proの設置は非常に楽で、付属のスリーエムの両面テープで貼り付けるだけ。意外と一度も取れていない。高さ調整用の金属部品が無骨ながらわりと精緻なつくりだったので、この部分を自分は気に入っている。ただ、無骨すぎて気に入らない人もいそうな見た目ではあると思う。\n\n電池交換のためにSESAME Touch Proを一度脱着する機会があったのだけど、これには少し苦労した。とはいえ結局、ものすごく力強く張り付いていてもヘラとシール剥がしがあれば簡単に取り外せることが分かったので、寧ろまた安心して取り付けられるようになった。このシール剥がしセット持ってると便利だと思うので、スマートロック付ける人にはおすすめしたい。この辺の詳細については、『[SESAME Touch Pro 取れない 対策](https://r7kamura.com/articles/2023-11-29-sesami-touch-pro)』という記事にまとめてある。\n\n## おわり\n\nSESAME 5とSESAME Touch Proが良いという話でした。\n\nなお、このウェブサイトでは商品紹介に普段からAmazonアソシエイトを利用しているということもあり、記事先頭に記載したリンク先はそれぞれAmazon.co.jpの商品ページへのリンクになっているけど、2023年12月8日現在では[公式サイトのオンラインストア](https://jp.candyhouse.co/products/sesame5)の方がいずれの商品も明らかに安いので、こちらから購入することをおすすめしたい。Amazonの方は「購入は全部Amazonで統一したい」とか「Amazonのポイントを消費したい」という人向け。\n","title":"スマートロックの『SESAME 5』と『SESAME Touch Pro』が良い","description":"SESAME 5とSESAME Touch Proを導入して、非常に満足しているという話。","imageUrl":"https://i.imgur.com/h8mqrdqh.jpg","renderedBody":"\u003cp\u003e\u003ca href=\"https://www.amazon.co.jp/dp/B0C22W4Y5H?tag=r7kamuracom-22\"\u003eSESAME 5\u003c/a\u003eと\u003ca href=\"https://www.amazon.co.jp/dp/B0C232GL4Q?tag=r7kamuracom-22\"\u003eSESAME Touch Pro\u003c/a\u003eを導入して、非常に満足しているという話。\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://i.imgur.com/h8mqrdqh.jpg\" alt=\"\" title=\"一回取り外してメンテ中のSESAME Touch Proの様子\"\u003e\u003cfigcaption\u003e一回取り外してメンテ中のSESAME Touch Proの様子\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2\u003eQrio Lock\u003c/h2\u003e\n\u003cp\u003e2019年12月から2023年9月までは、Qrio Lockというスマートロックを使っていた。2019年の時点では、スマートロックの導入として非常に良い選択肢だったと思っているけれど、この製品には幾つかの不満も抱えていた。\u003c/p\u003e\n\u003cp\u003eQrio Lockの解錠の方法として、ジオフェンス (要はスマホが近付いたら位置情報を元に自動的に解錠するやつ) を使うか、あるいはそれが効かない場合にはiPhoneのアプリを使っていた。\u003c/p\u003e\n\u003cp\u003eジオフェンスで解錠が完全に自動化されて最高かと思いきや、この解錠方法に大きな不満があった。この機能は玄関から大体100mぐらい離れた場所に移動して帰ってきた場合にしか作動しないので、例えばゴミ捨てに少しだけ外に出た場合には動作しない。また、動作するまでに数秒から十数秒かかることや、上手く検知されず解錠されない場合があったりして、玄関の前でしばらく立ち尽くすことが多く、結局それを嫌ってiPhoneのアプリを開いて解錠するということが増えていた。\u003c/p\u003e\n\u003cp\u003eいい大人がマンションの玄関の前で立ち尽くしている構図って、なんだか寂しいものがありますよね。万が一他の住民がたまたまそのタイミングで通りがかったときに備えて、私はUberの配達員のフリをする心構えをしていましたが、結局一度もその機会は訪れませんでした。\u003c/p\u003e\n\u003ch2\u003eSESAME 5 と SESAME Touch Pro\u003c/h2\u003e\n\u003cp\u003e2023年6月、SESAME 5とSESAME Touch Proが新たに発売されるということを知り、少し調べた結果以下の機能があることが分かり、購入に踏み切った。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e指紋認証で解錠できる\u003c/li\u003e\n\u003cli\u003eNFC端末で解錠できる\u003c/li\u003e\n\u003cli\u003eアプリで解錠できる\u003c/li\u003e\n\u003cli\u003eパスコードで解錠できる\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e指紋認証。これが一番利用頻度が高くて、普段解錠するのに使っている。100個まで登録できるので、指が多くても安心。\u003c/p\u003e\n\u003cp\u003eNFC端末。要するにスマホを近付けたら解錠できますよというやつ。これは冬場に解錠するのに使っている。なぜなら、冬場の外出時は常に手袋をしているから。iPhoneをNFC端末として登録している。エクスプレスモード (iPhoneのロックを解除しなくてもICカード機能が使えるやつ) にも対応しているけど、iPhoneを盗られたときに侵入されるリスクがあるので、今のところエクスプレスモードは解錠には使っていない。\u003c/p\u003e\n\u003cp\u003eアプリでの解錠。客人が帰るとき、基本的に自分より相手が先に玄関側に辿り着いてしまうので、靴を履いたりしている間にスマホで解錠している。勿論、解錠の手間を減らしてあげたいという配慮でもあるのだけど、それが主な目的ではない。スマートロックって両面テープで貼り付けているだけなので、施錠されている状態で事情を知らず力強く玄関が押されると、外れてしまったり、最悪壊れたりしてしまうことがあるので、それを防止したいという背景がある。解錠時にモーター音がある程度鳴る設計だと、「ああ何らかの仕組みで解錠されたんだな」ということが相手にも分かるので、この辺は完全に静音であるより、ある程度音があった方が都合が良かったりする。アプリでの解錠は、SESAME Touch Proの電池が切れたり動作不良を起こしたときのための緊急手段としても使っている。\u003c/p\u003e\n\u003cp\u003eパスコード。文字盤で適当な数字を入力したら解錠できるやつ。極稀にトリッキーな用途で使っている。事前に一時的なパスコードを幾つか登録しておいて、家族や親しい友達が先に自宅に着いてしまったときにパスコードを連絡して先に入っておいてもらう、といった使い方。100個まで登録できるので、友達が多くても安心。\u003c/p\u003e\n\u003ch2\u003e設置と脱着\u003c/h2\u003e\n\u003cp\u003eSESAME 5とSESAME Touch Proの設置は非常に楽で、付属のスリーエムの両面テープで貼り付けるだけ。意外と一度も取れていない。高さ調整用の金属部品が無骨ながらわりと精緻なつくりだったので、この部分を自分は気に入っている。ただ、無骨すぎて気に入らない人もいそうな見た目ではあると思う。\u003c/p\u003e\n\u003cp\u003e電池交換のためにSESAME Touch Proを一度脱着する機会があったのだけど、これには少し苦労した。とはいえ結局、ものすごく力強く張り付いていてもヘラとシール剥がしがあれば簡単に取り外せることが分かったので、寧ろまた安心して取り付けられるようになった。このシール剥がしセット持ってると便利だと思うので、スマートロック付ける人にはおすすめしたい。この辺の詳細については、『\u003ca href=\"https://r7kamura.com/articles/2023-11-29-sesami-touch-pro\"\u003eSESAME Touch Pro 取れない 対策\u003c/a\u003e』という記事にまとめてある。\u003c/p\u003e\n\u003ch2\u003eおわり\u003c/h2\u003e\n\u003cp\u003eSESAME 5とSESAME Touch Proが良いという話でした。\u003c/p\u003e\n\u003cp\u003eなお、このウェブサイトでは商品紹介に普段からAmazonアソシエイトを利用しているということもあり、記事先頭に記載したリンク先はそれぞれAmazon.co.jpの商品ページへのリンクになっているけど、2023年12月8日現在では\u003ca href=\"https://jp.candyhouse.co/products/sesame5\"\u003e公式サイトのオンラインストア\u003c/a\u003eの方がいずれの商品も明らかに安いので、こちらから購入することをおすすめしたい。Amazonの方は「購入は全部Amazonで統一したい」とか「Amazonのポイントを消費したい」という人向け。\u003c/p\u003e\n"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"B26M1Z0qIH0PJXyF36siN","isFallback":false,"gsp":true,"scriptLoader":[]}</script><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer><deepl-input-controller><template shadowrootmode="open"><link rel="stylesheet" href="chrome-extension://cofdbpoegempjloogbagkncekinflcnj/build/content.css"><div><div class="dl-input-translation-container svelte-ju4595"><div></div></div></div></template></deepl-input-controller><script src="./r7kamura_files/[articleName]-8ca6a25b238725bc.js"></script></body></html>