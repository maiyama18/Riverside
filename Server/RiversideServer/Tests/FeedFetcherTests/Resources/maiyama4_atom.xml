<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja">
  <title>maiyama log</title>
  
  <link href="https://maiyama4.hatenablog.com/"/>
  <updated>2023-12-27T14:26:25+09:00</updated>
  <author>
    <name>maiyama4</name>
  </author>
  <generator uri="https://blog.hatena.ne.jp/" version="27e23b99d2215e2e859afb2c9ea661">Hatena::Blog</generator>
  <id>hatenablog://blog/820878482964562935</id>

  
    
    
    <entry>
        <title>個人開発の SwiftUI アプリのアーキテクチャを MVVM から MV にした</title>
        <link href="https://maiyama4.hatenablog.com/entry/2023/12/27/142625"/>
        <id>hatenablog://entry/6801883189050663007</id>
        <published>2023-12-27T14:26:25+09:00</published>
        <updated>2023-12-27T14:26:25+09:00</updated>        <summary type="html">概要 SwiftUI Advent Calendar 2023 の 21 日目です。 最近趣味で iOS の podcast クライアントを SwiftUI で作っているのですが、やってみると podcast クライアントはアプリとしてそれなりに難しいことがわかってきました。作っているうちにどんどん状態管理が複雑になってきて、個人開発でなぜこんなにがんばりが必要なんだと思って開発が止まっていたのですが、最近 iOS 17 の登場をきっかけにアプリを全般的に書き直すことにして、同時にアーキテクチャを変えてみました。これにより構成がシンプルになって開発効率が上がり、開発を再開することができました。…</summary>
        <content type="html">&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://qiita.com/advent-calendar/2023/swiftui&quot;&gt;SwiftUI Advent Calendar 2023&lt;/a&gt; の 21 日目です。&lt;/p&gt;

&lt;p&gt;最近趣味で &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; の &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/podcast&quot;&gt;podcast&lt;/a&gt; クライアントを SwiftUI で作っているのですが、やってみると &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/podcast&quot;&gt;podcast&lt;/a&gt; クライアントはアプリとしてそれなりに難しいことがわかってきました。作っているうちにどんどん状態管理が複雑になってきて、個人開発でなぜこんなにがんばりが必要なんだと思って開発が止まっていたのですが、最近 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; 17 の登場をきっかけにアプリを全般的に書き直すことにして、同時に&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;を変えてみました。これにより構成がシンプルになって開発効率が上がり、開発を再開することができました。具体的には、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;from:  １画面に１つ ViewModel（&lt;code&gt;ObservableObject&lt;/code&gt;）を作り、 View から ViewModel を監視する MVVM&lt;/li&gt;
&lt;li&gt;to: View から直接 Model （&lt;code&gt;@Observable&lt;/code&gt;）を監視する MV&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;という変更しました。要は ViewModel を消したということです。&lt;/p&gt;

&lt;p&gt;今まであまりモバイルアプリの&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;にこだわりがなかったのですが、&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;の変更で開発のしやすさやモチベーションに大きな影響が出てなるほど〜と思ったので、一つの事例としてこの記事で MV &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;についてまとめてみようと思います。&lt;/p&gt;

&lt;p&gt;前提として、アプリにどの&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;が適しているかは要件や開発チームの規模などによって大きく変わると思っています。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;SwiftUI アプリにおける MV &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;のメリットはすでにいくつかリソースで解説されています。とくに参考になると思っているものを２つ貼っておきます。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fazamsharp.com%2F2022%2F10%2F06%2Fpractical-mv-pattern-crud.html&quot; title=&quot;Practical Mv Pattern Crud&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://azamsharp.com/2022/10/06/practical-mv-pattern-crud.html&quot;&gt;azamsharp.com&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/cGz17zcmfK4?feature=oembed&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen title=&quot;SwiftUIを使ってiOSアプリを作るシンプルな方法&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=cGz17zcmfK4&quot;&gt;www.youtube.com&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;h2 id=&quot;MVVM-の大変さ&quot;&gt;MVVM の大変さ&lt;/h2&gt;

&lt;p&gt;MVVM でアプリを作っていて大変に感じていたのは、画面ごとに Model と ViewModel のデータを同期するコードを書かなければいけないことに尽きます。&lt;/p&gt;

&lt;p&gt;例として、カウンターアプリを考えます。単純に考えるとカウンターの Model は以下のようにしたい...&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CounterModel&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterModel&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;()

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;increment&lt;/span&gt;() {
        count &lt;span class=&quot;synIdentifier&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;
    }
}
&lt;/pre&gt;


&lt;p&gt;が、 &lt;code&gt;count&lt;/code&gt; の更新をきっかけに View の再描画をしたいという要件が発生したとします。 Model が持つ状態の更新を View にリアルタイムに反映したいというのはかなりよくある状況のはずです。そうすると、なんらかの形で外部から Model の更新を購読できるようにしたいので、例えば以下のようになるでしょう。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CounterModel&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterModel&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;()
    
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;countPublisher&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; Publisher&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;&lt;/span&gt;Int, Never&lt;span class=&quot;synIdentifier&quot;&gt;&amp;gt;&lt;/span&gt; { countSubject }
    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;countSubject&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CurrentValueSubject&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;Never&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;increment&lt;/span&gt;() {
        countSubject.send(countSubject.value &lt;span class=&quot;synIdentifier&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;)
    }
}
&lt;/pre&gt;


&lt;p&gt;ViewModel と View は以下のような感じになりそうです。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;AScreenViewModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;ObservedObject&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@Published&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;var&lt;/span&gt; formattedCount&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt;

    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;cancellables&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;AnyCancellable&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;()
    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;counterModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterModel&lt;/span&gt;

    &lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;(counterModel&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterModel&lt;/span&gt;) {
        &lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;.counterModel &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; counterModel

        counterModel
            .countPublisher
            .sink { [&lt;span class=&quot;synStatement&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;] &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;?.formattedCount &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt; }
            .store(&lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;&lt;/span&gt;cancellables)
    }

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;increment&lt;/span&gt;() {
        counterModel.increment()
    }
}

&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;AScreen&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@StateObject&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;AScreenViewModel&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;(counterModel&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterModel.shared&lt;/span&gt;)

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        VStack {
            Text(viewModel.formattedCount)

            Button(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Increment&amp;quot;&lt;/span&gt;) {
                viewModel.increment()
            }
        }
        .navigationTitle(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;)
    }
}
&lt;/pre&gt;


&lt;p&gt;ここで面倒なのは &lt;code&gt;CounterModel&lt;/code&gt; の &lt;code&gt;count&lt;/code&gt; と &lt;code&gt;AScreenViewModel&lt;/code&gt; の &lt;code&gt;count&lt;/code&gt; が常に同じ値であるべきなのに別のクラスのプロパティとしてそれぞれ存在するため、同期を取るコードが必要になっていることです。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;        &lt;span class=&quot;synComment&quot;&gt;// ここで Model と ViewModel のデータを同期している&lt;/span&gt;
        counterModel
            .countPublisher
            .sink { [&lt;span class=&quot;synStatement&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;] &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;?.formattedCount &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt; }
            .store(&lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;&lt;/span&gt;cancellables)
&lt;/pre&gt;


&lt;p&gt;今回は Combine の &lt;code&gt;Publisher&lt;/code&gt; を使って同期を行っていますが、他の方法を取る場合でも何かしら同じようなコードは存在することになるでしょう。ここでは考慮していませんが、適切なタイミングで購読をキャンセルすることを考えるとさらに追加で処理を書く必要があります。&lt;/p&gt;

&lt;p&gt;ここまでの例だと同期すべきプロパティが１つで、かつ画面も１つなので大した手間ではないですが、これが他の画面からも &lt;code&gt;CounterModel&lt;/code&gt; を見るようになったり、逆に &lt;code&gt;AScreenViewModel&lt;/code&gt; が他の Model も見るようになったりすると同期を取るコードがどんどん増えていって大変になってきます。例えば、 &lt;code&gt;BScreenViewModel&lt;/code&gt; や &lt;code&gt;CScreenViewModel&lt;/code&gt; でも &lt;code&gt;count&lt;/code&gt; を表示したいとなってくると毎回同じかつ、あまり本質的とはいえないコードを書く必要があるので気が滅入ってくることになります。&lt;/p&gt;

&lt;h2 id=&quot;MV-にするとどうなるか&quot;&gt;MV にするとどうなるか&lt;/h2&gt;

&lt;p&gt;ということ&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%D7%A5%EA%B3%AB%C8%AF&quot;&gt;アプリ開発&lt;/a&gt;の厳しさを味わっていた中、 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; 17 で登場した &lt;code&gt;@Observable&lt;/code&gt; を使って、&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;も含めてアプリを書き直してみようと思いました。大変さの根源は Model の情報を View が表示する、というフローの間に ViewModel が介在することだったので、 ViewModel を排して View から Model を直接見る、いわゆる MV &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;にしてみます。&lt;/p&gt;

&lt;p&gt;Model の更新を View に反映できるようにしたいので、 &lt;code&gt;CounterModel&lt;/code&gt; 自体を &lt;code&gt;@Observable&lt;/code&gt; にします。 &lt;code&gt;@Observable&lt;/code&gt; の仕組みにより、 &lt;code&gt;Combine.Publisher&lt;/code&gt; や &lt;code&gt;AsyncStream&lt;/code&gt; などを使わずとも、ただのプロパティである &lt;code&gt;count&lt;/code&gt; を View から監視することが可能です。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;@Observable&lt;/span&gt;
&lt;span class=&quot;synType&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CounterModel&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;increment&lt;/span&gt;() {
        count &lt;span class=&quot;synIdentifier&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;CounterModel&lt;/code&gt; はアプリ全体で共有したいため &lt;code&gt;.environment&lt;/code&gt; に入れておきます。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;@main&lt;/span&gt;
&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CounterApp&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;App&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;counterModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterModel&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;()
    
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; Scene {
        WindowGroup {
            ContentView()
                .environment(counterModel)
        }
    }
}
&lt;/pre&gt;


&lt;p&gt;これを View から取得して利用します。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;AScreen&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@Environment&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;CounterModel.self&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;counterModel&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        VStack {
            Text(counterModel.count, format&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; .number)

            Button(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Increment&amp;quot;&lt;/span&gt;) {
                counterModel.increment()
            }
        }
        .navigationTitle(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;)
    }
}
&lt;/pre&gt;


&lt;p&gt;以上です。データが Model にしか存在しないことで、アプリ全体のコードがすごくシンプルになっていることがわかります。この方法なら、他の画面が &lt;code&gt;CounterModel&lt;/code&gt; を参照したいとなっても、 &lt;code&gt;@Environment&lt;/code&gt; で取得してただ利用すればいいので、 MVVM と比較するとかなり手間が減ります。&lt;/p&gt;

&lt;h2 id=&quot;Observable-はプロパティベースの監視&quot;&gt;&lt;code&gt;@Observable&lt;/code&gt; はプロパティベースの監視&lt;/h2&gt;

&lt;p&gt;Model は ViewModel と違ってアプリ全体で共有されています。これは、 Model が各 View 専用に作られていない、つまり Model が View が必要としないプロパティも持ってしまっていることを意味しています。そのため、 View から直接 Model を見ることで必要ないプロパティが更新されたときにも View の body の再評価が走ってパフォーマンスの問題が出るという懸念があるかもしれません。極端な例ですが、例えば以下の Model を画面 A / B / C から &lt;code&gt;@Environment&lt;/code&gt; を介して監視したときに、 &lt;code&gt;propertyForA&lt;/code&gt; が更新された際に画面 A だけではなく B / C も無駄に再描画が走ってしまうのではないかということです。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;Model&lt;/span&gt; {
    &lt;span class=&quot;synComment&quot;&gt;// 画面 A だけで使われる&lt;/span&gt;
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;propertyForA&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;synComment&quot;&gt;// 画面 B だけで使われる&lt;/span&gt;
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;propertyForB&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;synComment&quot;&gt;// 画面 C だけで使われる&lt;/span&gt;
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;propertyForC&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;
}
&lt;/pre&gt;


&lt;p&gt;実際に &lt;code&gt;ObservableObject&lt;/code&gt; ではこの問題が存在していました。&lt;code&gt;ObservableObject&lt;/code&gt; の更新をきっかけに SwiftUI の View が再描画されるのは、 &lt;code&gt;@Published&lt;/code&gt; プロパティが更新されることで &lt;code&gt;ObservableObject&lt;/code&gt; の &lt;code&gt;objectWillChange&lt;/code&gt; publisher が発火するためです。つまり、 &lt;code&gt;@Published&lt;/code&gt; プロパティがどれか１つでも更新されることで &lt;code&gt;ObservableObject&lt;/code&gt; 全体に紐づく publisher が発火するオブジェクト単位の監視となっていて、監視している &lt;code&gt;ObservableObject&lt;/code&gt; のうち View が使っていないプロパティが更新されても View の body が再評価されてしまうことになります。どれくらいの規模のアプリになると実際にパフォーマンスの問題が出てくるのかは検証が難しいですが、避けられるなら避けたい現象です。&lt;/p&gt;

&lt;p&gt;この問題は &lt;code&gt;@Observable&lt;/code&gt; では解消しています。というのも &lt;code&gt;@Observable&lt;/code&gt; では監視がプロパティ単位になっているため、 View が使っていないプロパティが更新されても body の再評価がされないようになっているためです。これにより、 Model を &lt;code&gt;@Environment&lt;/code&gt; でいろいろな View から監視するという一見すごく乱暴そうなことをしても必要なタイミングにのみ再描画が走ることになります（と思っているのですが、もし勘違いしていたら教えてください）。 &lt;code&gt;ObservableObject&lt;/code&gt; を使っている場合は、無駄な再描画が走らないように Model から View が使うデータのみを抽出するという意味でも ViewModel を挟むメリットがありましたが、 &lt;code&gt;@Observable&lt;/code&gt; ではその点に関しては Model を View から直接監視しても問題がなくなったと思っています。&lt;/p&gt;

&lt;h2 id=&quot;プレゼンテーションロジックをどうするか&quot;&gt;プレゼンテーションロジックをどうするか&lt;/h2&gt;

&lt;p&gt;ViewModel を使いたくなる理由の一つにプレゼンテーションロジックを置きたいというものがあります。 View に紐づくロジックが複雑な場合、&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%C3%B1%C2%CE%A5%C6%A5%B9%A5%C8&quot;&gt;単体テスト&lt;/a&gt;を書いたり、 View を煩雑にしないために ViewModel にまとめたくなってきます。&lt;/p&gt;

&lt;p&gt;例えば、 &lt;code&gt;AScreen&lt;/code&gt; では &lt;code&gt;CounterModel&lt;/code&gt; の &lt;code&gt;count&lt;/code&gt; をそのまま表示していましたが、 &lt;code&gt;BScreen&lt;/code&gt; では &lt;code&gt;count&lt;/code&gt; を &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/FizzBuzz&quot;&gt;FizzBuzz&lt;/a&gt; で表示したいとします。このロジックは &lt;code&gt;BScreen&lt;/code&gt; にしか関係ないので &lt;code&gt;CounterModel&lt;/code&gt; には書きたくないですが、 View に直接書くにしては複雑という考えもありそうだし、&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%C3%B1%C2%CE%A5%C6%A5%B9%A5%C8&quot;&gt;単体テスト&lt;/a&gt;がやりづらくなります。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;BScreen&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@Environment&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;CounterModel.self&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;counterModel&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        VStack {
            Text(counterModel.count, format&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; .number)

            Button(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Increment&amp;quot;&lt;/span&gt;) {
                counterModel.increment()
            }
        }
        .navigationTitle(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;)
    }

    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;formattedCount&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt; {
        &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; counterModel.count &lt;span class=&quot;synIdentifier&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt; }

        &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;switch&lt;/span&gt; (counterModel.count &lt;span class=&quot;synIdentifier&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;, counterModel.count &lt;span class=&quot;synIdentifier&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;3&lt;/span&gt;) {
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;FizzBuzz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;, _)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Fizz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (_, &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Buzz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;counterModel.count&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;
        }
    }
}
&lt;/pre&gt;


&lt;p&gt;もちろんこのようなロジックのために ViewModel を作るという選択肢もあるのですが、あえて画面に紐づく ViewModel としなくても単にロジックをオブジェクトや関数にまとめてもよさそうです。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;ContentView&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@Environment&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;CounterModel.self&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;counterModel&lt;/span&gt;
    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;countFormatter&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CountFormatter&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;()

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        VStack {
            Text(countFormatter.fizzBuzz(count&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;counterModel.count&lt;/span&gt;))

            Button(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Increment&amp;quot;&lt;/span&gt;) {
                counterModel.increment()
            }
        }
        .navigationTitle(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;)
    }
}

&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CountFormatter&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;fizzBuzz&lt;/span&gt;(count&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;synSpecial&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt; {
        &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; count &lt;span class=&quot;synIdentifier&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt; }

        &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;switch&lt;/span&gt; (count &lt;span class=&quot;synIdentifier&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;, count &lt;span class=&quot;synIdentifier&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;3&lt;/span&gt;) {
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;FizzBuzz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;, _)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Fizz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (_, &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Buzz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;count&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;
        }
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;CountFormatter#fizzBuzz&lt;/code&gt; は単なるメソッドなので簡単にテストすることができます。このように、ある程度以上の複雑さを持ったプレゼンテーションロジックが存在する場合でも、必ずしもそのために ViewModel を作る必要はなさそうです。&lt;/p&gt;

&lt;h2 id=&quot;ViewModel-を作りたい場合&quot;&gt;ViewModel を作りたい場合&lt;/h2&gt;

&lt;p&gt;なんらかの理由で、やはり ViewModel が必要ということがあるかもしれません。基本的には MV &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;で画面を作り、どうしても必要な箇所のみ MVVM にするということも可能です。&lt;/p&gt;

&lt;p&gt;例えば、以下のように &lt;code&gt;BScreen&lt;/code&gt; 用の ViewModel を作り、プレゼンテーションロジックを持たせることもできます。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;@Observable&lt;/span&gt;
&lt;span class=&quot;synType&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;BScreenViewModel&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;counterModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterModel&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;formattedCount&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt; {
        &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; counterModel.count &lt;span class=&quot;synIdentifier&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;0&amp;quot;&lt;/span&gt; }

        &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;switch&lt;/span&gt; (counterModel.count &lt;span class=&quot;synIdentifier&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;, counterModel.count &lt;span class=&quot;synIdentifier&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;3&lt;/span&gt;) {
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;FizzBuzz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;, _)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Fizz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;case&lt;/span&gt; (_, &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Buzz&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;counterModel.count&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;
        }
    }

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;increment&lt;/span&gt;() {
        counterModel.increment()
    }
}
&lt;/pre&gt;


&lt;p&gt;ここで、 &lt;code&gt;@Observable&lt;/code&gt; である &lt;code&gt;BScreenViewModel&lt;/code&gt; の中にさらに &lt;code&gt;@Observable&lt;/code&gt; の &lt;code&gt;CounterModel&lt;/code&gt; がネストしているところが注目ポイントです。このように &lt;code&gt;@Observable&lt;/code&gt; がネストした状況であっても、内側の &lt;code&gt;@Observable&lt;/code&gt; である &lt;code&gt;CounterModel&lt;/code&gt; の更新に合わせて外側の &lt;code&gt;@Observable&lt;/code&gt; の &lt;code&gt;BScreenViewModel&lt;/code&gt; を監視している View の再描画が走ってくれます。この仕組みを利用すれば、基本的には View は直接 Model を見るが、場合によっては途中に ViewModel を挟むということもやりやすいと思います。&lt;/p&gt;

&lt;p&gt;実は、 &lt;code&gt;ObservableObject&lt;/code&gt; では、ネストした場合に内側の &lt;code&gt;ObservableObject&lt;/code&gt; が更新されても View が更新されないという問題があったのでこの方法は取れませんでした。以下のリンクのような工夫をすればネストした &lt;code&gt;ObservableObject&lt;/code&gt; を動作させることはできるということになっていますが、 &lt;code&gt;@Observable&lt;/code&gt; でそういったハックなしにうまく動作するようになって最高です。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fstackoverflow.com%2Fa%2F58406402&quot; title=&quot;How to tell SwiftUI views to bind to nested ObservableObjects&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/a/58406402&quot;&gt;stackoverflow.com&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;h2 id=&quot;FetchRequest-などのプロパティラッパー&quot;&gt;&lt;code&gt;@FetchRequest&lt;/code&gt; などのプロパティラッパー&lt;/h2&gt;

&lt;p&gt;Core Data の &lt;code&gt;@FetchRequest&lt;/code&gt; や UserDefaults を見る &lt;code&gt;@AppStorage&lt;/code&gt; などデータ層を SwiftUI に統合しやすくするプロパティラッパーがいろいろと用意されていますが、個人的にはこれまではあまり使おうと思っていませんでした。 View 層から &lt;code&gt;import CoreData&lt;/code&gt; するのは気持ち悪い感じがするし、データ関連のテストがしづらいためです。そのため、これまでは ViewModel から &lt;code&gt;NSFetchedResultsController&lt;/code&gt; を使い、データを &lt;code&gt;ObservableObject&lt;/code&gt; の &lt;code&gt;@Published&lt;/code&gt; プロパティに流すことで Core Data の更新を View に反映させるということをやっていました。&lt;/p&gt;

&lt;p&gt;しかし、いざ &lt;code&gt;@FetchRequest&lt;/code&gt; を使ってみると、 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Apple&quot;&gt;Apple&lt;/a&gt; がちゃんと作ってくれているはずの &lt;code&gt;@FetchRequest&lt;/code&gt; がデータ関連の全てをやってくれるのですごく使用感がよかったです。もちろんテストは書きづらくなるのですが、今まで自分で書いていたデータ関連のロジックをほとんど &lt;code&gt;@FetchRequest&lt;/code&gt; がやってくれるのでそもそもテストを書く必要性自体がなくなると感じることが多かったです。ViewModel を介さないことで &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Apple&quot;&gt;Apple&lt;/a&gt; の&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF&quot;&gt;フレームワーク&lt;/a&gt;の SwiftUI 統合がそのまま使えるという良さもあります。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;あくまで個人開発かつ N=1 の話ではありますが、 &lt;code&gt;ObservableObject&lt;/code&gt; と MVVM &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;で作っていたアプリを &lt;code&gt;@Observable&lt;/code&gt; と MV &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;に移行したら開発がしやすくなったという話でした。 &lt;code&gt;@Observable&lt;/code&gt; は &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; 17 以上でしか使えないのでまだ多くのユーザがいるアプリで使うのは厳しいとは思いますが、そのうち使えるのを楽しみにしておきましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ViewModel がなくなることで ViewModel と Model のデータの同期を取るコードを書かなくてよくなりうれしい&lt;/li&gt;
&lt;li&gt;ViewModel に書いていたようなプレゼンテーションロジックは専用のオブジェクトや関数にまとめることで&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%C3%B1%C2%CE%A5%C6%A5%B9%A5%C8&quot;&gt;単体テスト&lt;/a&gt;することが可能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ObservableObject&lt;/code&gt; から &lt;code&gt;@Observable&lt;/code&gt; の進化も MV &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3&quot;&gt;アーキテクチャ&lt;/a&gt;でアプリを書いていくための助けになった

&lt;ul&gt;
&lt;li&gt;オブジェクト単位からプロパティ単位での監視になったので、使っていないプロパティの更新によって無駄に View の再描画が走るということがなくなった&lt;/li&gt;
&lt;li&gt;ネストした &lt;code&gt;@Observable&lt;/code&gt; もうまく動作するようになったので、万が一必要になったら ViewModel 層を差し込むということもできる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@FetchRequest&lt;/code&gt; などの SwiftUI 組み込みのプロパティラッパーも冷静に考えると便利なのでどんどん使っていきたい&lt;/li&gt;
&lt;/ul&gt;

</content>        
        <link rel="enclosure" href="https://cdn.blog.st-hatena.com/images/theme/og-image-1500.png" type="image/png" length="0" />

        <author>
            <name>maiyama4</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>uber/needle を使いはじめるためのメンタルモデル</title>
        <link href="https://maiyama4.hatenablog.com/entry/2023/12/18/153701"/>
        <id>hatenablog://entry/820878482974423998</id>
        <published>2023-12-18T15:37:01+09:00</published>
        <updated>2023-12-18T15:37:01+09:00</updated>        <summary type="html">概要 最近 uber/needle を使う機会があったので入門しました。この記事では needle を使い始めるためにざっくり持っておくと便利なイメージのようなものをまとめます。 uber/needle とは needle は Swift で DI を行うためのライブラリです。類似ライブラリの中でもけっこう有名な方で、 iOS アプリに DI の仕組みを入れようとなったときに利用するライブラリの検討候補には上がってくるのではないかと思います。 DI は依存関係を実行時に解決する動的な DI とビルド時に解決する静的な DI にざっくり分けられますが、 needle は後者の静的な DI をコー…</summary>
        <content type="html">&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;最近 &lt;a href=&quot;https://github.com/uber/needle&quot;&gt;uber/needle&lt;/a&gt; を使う機会があったので入門しました。この記事では needle を使い始めるためにざっくり持っておくと便利なイメージのようなものをまとめます。&lt;/p&gt;

&lt;h2 id=&quot;uberneedle-とは&quot;&gt;&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/uber&quot;&gt;uber&lt;/a&gt;/needle とは&lt;/h2&gt;

&lt;p&gt;needle は Swift で DI を行うためのライブラリです。類似ライブラリの中でもけっこう有名な方で、 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; アプリに DI の仕組みを入れようとなったときに利用するライブラリの検討候補には上がってくるのではないかと思います。&lt;/p&gt;

&lt;p&gt;DI は依存関係を実行時に解決する動的な DI とビルド時に解決する静的な DI にざっくり分けられますが、 needle は後者の静的な DI をコード生成により実現しています。静的な DI では実行時に存在するはず依存が取得できなくてクラッシュするような問題が発生しないので、それが needle のメリットの１つとなっています。&lt;/p&gt;

&lt;p&gt;needle は、コード生成を行う &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/CLI&quot;&gt;CLI&lt;/a&gt; とアプリに統合する &lt;code&gt;NeedleFoundation&lt;/code&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF&quot;&gt;フレームワーク&lt;/a&gt;の２つの部品からなっています。&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/CLI&quot;&gt;CLI&lt;/a&gt; は手動で&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3&quot;&gt;コマンドライン&lt;/a&gt;で実行することもできますが、ちゃんとしたアプリにおいては Build Phases のどこかで実行するのがよいでしょう。&lt;/p&gt;

&lt;p&gt;インストールの方法は &lt;a href=&quot;https://github.com/uber/needle#installation&quot;&gt;README&lt;/a&gt; にまとまっています。&lt;/p&gt;

&lt;h2 id=&quot;Component-と-Dependency&quot;&gt;&lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;Dependency&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;needle の README を読んでみると少し難しそうな雰囲気がただよっていますが、実際に入門してみると非常に簡単で理解するべき概念は &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;Dependency&lt;/code&gt; の２つだけです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/uber/needle/blob/master/API.md#components&quot;&gt;ドキュメント&lt;/a&gt; を読むと &lt;code&gt;Component&lt;/code&gt; はスコープだとか階層構造を作るとかいろいろ書いてありますが、入門時には「画面を作ることに責任を持つもの」と考えておくとわかりやすいと思っています。必ずしもそうする必要はないですが、画面 A / B / C と３つ作るときには &lt;code&gt;Component&lt;/code&gt; も対応させて A / B / C の３つを作ることが多く、公式のサンプルでもそうなっています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Component&lt;/code&gt; が画面を作るぞ！と思ったところで無から画面を作るわけにはいかなくて、普通は &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/API&quot;&gt;API&lt;/a&gt; なりデータベースなりに依存することになります。この依存をまとめたものが &lt;code&gt;Dependency&lt;/code&gt; です。１つの &lt;code&gt;Component&lt;/code&gt; には１つの &lt;code&gt;Dependency&lt;/code&gt; が対応するので、例えば画面 A を作る場合には &lt;code&gt;AComponent&lt;/code&gt; と &lt;code&gt;ADependency&lt;/code&gt; を用意することになります。画面 A が必要とする依存が &lt;code&gt;ADependency&lt;/code&gt; にまとめられ、それを利用して &lt;code&gt;AComponent&lt;/code&gt; が画面を生成します。&lt;/p&gt;

&lt;h2 id=&quot;画面を作ってみる--Component-と-Dependency&quot;&gt;画面を作ってみる : &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;Dependency&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;実際に needle の &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;Dependency&lt;/code&gt; を使って SwiftUI で画面を作ってみます。題材として、ランダムな番号をいくつか表示する画面を作ることにします。まず、 View を以下のように作ってしまいましょう。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// NumbersScreen.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; SwiftUI

&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;NumbersScreen&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@State&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;randomNumbers&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; []

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        NavigationView {
            List {
                ForEach(randomNumbers, id&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; \.&lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;) { number &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt;
                    Text(number, format&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; .number)
                }
            }
            .toolbar {
                ToolbarItem {
                    Button(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Refresh&amp;quot;&lt;/span&gt;) {
                        refreshRandomNumbers()
                    }
                }
            }
        }
        .onAppear {
            refreshRandomNumbers()
        }
    }

    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;refreshRandomNumbers&lt;/span&gt;() {
        &lt;span class=&quot;synComment&quot;&gt;// &lt;/span&gt;&lt;span class=&quot;synTodo&quot;&gt;TODO&lt;/span&gt;&lt;span class=&quot;synComment&quot;&gt;: 番号を取得して randomNumbers に代入する&lt;/span&gt;
    }
}
&lt;/pre&gt;


&lt;p&gt;ランダムな番号を取得して画面に反映するメソッドである &lt;code&gt;refreshRandomNumbers&lt;/code&gt; は一旦 TODO にしてありますが、 View 自体はこれで完成です。&lt;/p&gt;

&lt;p&gt;先ほども書いたように、 needle において画面を作ることに責任を持つのは &lt;code&gt;Component&lt;/code&gt; なので、 &lt;code&gt;NumbersScreen&lt;/code&gt; を生成する &lt;code&gt;NumbersComponent&lt;/code&gt; を作ることにします。 &lt;code&gt;Component&lt;/code&gt; は &lt;code&gt;NeedleFoundation&lt;/code&gt; の &lt;code&gt;Component&lt;/code&gt; クラスを継承して作ります。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// NumbersScreen.swift&lt;/span&gt;

&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;NumbersComponent&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;EmptyDependency&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;build&lt;/span&gt;() &lt;span class=&quot;synSpecial&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        NumbersScreen()
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;Component&lt;/code&gt; がどうやって画面を作るかは needle が定めているわけではないので、好きに作って OK です。今回の &lt;code&gt;NumbersComponent&lt;/code&gt; では &lt;code&gt;build&lt;/code&gt; というメソッドに &lt;code&gt;NumbersScreen&lt;/code&gt; を生成して返してもらっています。 &lt;code&gt;Dependency&lt;/code&gt; は &lt;code&gt;Component&lt;/code&gt; と１対１に対応しますが、これは &lt;code&gt;Component&lt;/code&gt; の型パラメータが &lt;code&gt;Dependency&lt;/code&gt; を受け取ることにより実現されています。ひとまず現状の &lt;code&gt;NumbersScreen&lt;/code&gt; は何も依存を必要としていないので、空の依存を表す &lt;code&gt;NeedleFoundation&lt;/code&gt; 組み込みの &lt;code&gt;EmptyDependency&lt;/code&gt; を利用しています。&lt;/p&gt;

&lt;p&gt;それでは、先ほど TODO にしていた &lt;code&gt;NumbersScreen#refreshRandomNumbers&lt;/code&gt; を埋めていきます。そのために、どこかからランダムな番号を取ってくる必要があります。いったん具体的な実装のことを考えずに protocol だけ定義することにします。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// RandomNumberFetcher.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;RandomNumbersFetcherProtocol&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;fetch&lt;/span&gt;() &lt;span class=&quot;synSpecial&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;]&lt;/span&gt;
}
&lt;/pre&gt;


&lt;p&gt;これを &lt;code&gt;NumberScreen&lt;/code&gt; に持たせ、 &lt;code&gt;refreshRandomNumbers&lt;/code&gt; の中で呼べば OK です。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// NumbersScreen.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;NumbersScreen&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synComment&quot;&gt;// ...&lt;/span&gt;

    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;randomNumbersFetcher&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;any&lt;/span&gt; RandomNumbersFetcherProtocol

    &lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;(randomNumbersFetcher&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;any&lt;/span&gt; RandomNumbersFetcherProtocol) {
        &lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;.randomNumbersFetcher &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; randomNumbersFetcher
    }

    &lt;span class=&quot;synComment&quot;&gt;// ...&lt;/span&gt;

    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;refreshRandomNumbers&lt;/span&gt;() {
        randomNumbers &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; randomNumbersFetcher.fetch()
    }
}
&lt;/pre&gt;


&lt;p&gt;View 側のコード変更としてはこれがすべてです。次に誰が &lt;code&gt;NumberScreen&lt;/code&gt; に &lt;code&gt;RandomNumbersFetcherProtocol&lt;/code&gt; を渡すのかという問題が出てきます。 &lt;code&gt;NumberScreen&lt;/code&gt; を作る責任は &lt;code&gt;NumbersComponent&lt;/code&gt; にあるので、最終的には &lt;code&gt;NumbersComponent&lt;/code&gt; に渡してもらう必要があります。しかし、 needle では &lt;code&gt;Component&lt;/code&gt; は必ずしも画面のための依存を生成する必要はなく、こういう依存がほしいよというのを &lt;code&gt;Dependency&lt;/code&gt; として宣言しておくだけで OK です。これにより、 &lt;code&gt;Component&lt;/code&gt; の中で使える &lt;code&gt;dependency&lt;/code&gt; というプロパティの中に望みの依存が入ってくることになります。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// NumbersScreen.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;NumbersDependency&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Dependency&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;randomNumbersFetcher&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;any&lt;/span&gt; RandomNumbersFetcherProtocol { &lt;span class=&quot;synStatement&quot;&gt;get&lt;/span&gt; }
}

&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;NumbersComponent&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;NumbersDependency&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;build&lt;/span&gt;() &lt;span class=&quot;synSpecial&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        NumbersScreen(randomNumbers Fetcjer&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;dependency.randomNumbersFetcher&lt;/span&gt;)
    }
}
&lt;/pre&gt;


&lt;p&gt;以上で、ランダムな番号を取得して表示する画面を作ることができました。もちろん、 &lt;code&gt;RandomNumbersFetcherProtocol&lt;/code&gt; を満たす実体の実装をしていないのでアプリとしては動作しないですが、画面の実装としては完了していて、たとえば &lt;code&gt;RandomNumbersFetcherProtocol&lt;/code&gt; のモックを作ってあげればプレビューやテストなどで画面の動作確認をすることもできます。&lt;/p&gt;

&lt;p&gt;ここまでの例で &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;Dependency&lt;/code&gt; についてなんとなく理解することができたと思います。画面が必要とする依存が &lt;code&gt;Dependency&lt;/code&gt; で、その &lt;code&gt;Dependency&lt;/code&gt; を元に画面を生成する責任を持つのが &lt;code&gt;Component&lt;/code&gt; です。&lt;/p&gt;

&lt;h2 id=&quot;アプリを動作させる--BootstrapComponent&quot;&gt;アプリを動作させる : &lt;code&gt;BootstrapComponent&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;続いて、実際にアプリを動作させていきます。まずは、 &lt;code&gt;RandomNumbersFetcherProtocol&lt;/code&gt; を実装してしまいます。その具体的な実装は needle を学ぶにあたっては関係ないので、その場で適当に &lt;code&gt;Int&lt;/code&gt; を5つ生成して配列に入れて返すことにします。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// RandomNumbersFetcher.swift&lt;/span&gt;

&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;RandomNumbersFetcher&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;RandomNumbersFetcherProtocol&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;fetch&lt;/span&gt;() &lt;span class=&quot;synSpecial&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;]&lt;/span&gt; {
        Array((&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;..&amp;lt;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;100&lt;/span&gt;).shuffled().&lt;span class=&quot;synStatement&quot;&gt;prefix&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;))
    }
}
&lt;/pre&gt;


&lt;p&gt;ここまでで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;画面（&lt;code&gt;NumbersScreen&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt;（&lt;code&gt;NumbersComponent&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dependency&lt;/code&gt;（&lt;code&gt;NumbersDependency&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dependency&lt;/code&gt; が必要とする依存（&lt;code&gt;RandomNumbersFetcherProtocol&lt;/code&gt; とその実装の &lt;code&gt;RandomNumbersFetcher&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;が揃ったことになります。アプリとして動作するための TODO として、&lt;code&gt;RandomNumberFetcher&lt;/code&gt; を実際に生成して &lt;code&gt;NumbersComponent&lt;/code&gt; に渡してあげる作業が残っています。&lt;/p&gt;

&lt;p&gt;needle において &lt;code&gt;Component&lt;/code&gt; は親子関係のツリーを作っていて、すべての &lt;code&gt;Component&lt;/code&gt; はそのツリーのどこかに属することになります。そして、ある &lt;code&gt;Component&lt;/code&gt; が依存を必要とするとき、その依存の protocol を自分の &lt;code&gt;Dependency&lt;/code&gt; に書いておくだけで、その &lt;code&gt;Component&lt;/code&gt; のツリー上の祖先の &lt;code&gt;Component&lt;/code&gt; が提供するその protocol の実装が取得できることになっています。これが needle による DI の核となる機能です。&lt;/p&gt;

&lt;p&gt;これまで、 &lt;code&gt;NumbersComponent&lt;/code&gt; は必要な依存を受け取って &lt;code&gt;NumbersScreen&lt;/code&gt; を生成するという責任しか持っていませんでした。しかし、一般の &lt;code&gt;Component&lt;/code&gt; は自分の子孫が利用する依存の実装を提供する責任も併せ持っているというわけです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Component&lt;/code&gt; の親子関係の中で特別なものとして&lt;code&gt;BootstrapComponent&lt;/code&gt; があります。&lt;code&gt;BootstrapComponent&lt;/code&gt; は、 &lt;code&gt;Component&lt;/code&gt; の親子関係のツリーのルート、つまりすべての &lt;code&gt;Component&lt;/code&gt; の親です。今回作っているアプリにはまだ &lt;code&gt;NumbersComponent&lt;/code&gt; しかないので、ツリーのルートに &lt;code&gt;BootstrapComponent&lt;/code&gt; があり、その唯一の子として &lt;code&gt;NumbersComponent&lt;/code&gt; があることになります。&lt;/p&gt;

&lt;p&gt;そのため、 &lt;code&gt;NumbersComponent&lt;/code&gt; に &lt;code&gt;RandomNumbersFetcher&lt;/code&gt; を提供する役割を持っているのは &lt;code&gt;BootstrapComponent&lt;/code&gt; です。 &lt;code&gt;BootstrapComponent&lt;/code&gt; を &lt;code&gt;RootComponent&lt;/code&gt; という名前で実装しましょう。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// NumbersApp.swift&lt;/span&gt;

&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;RootComponent&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;BootstrapComponent&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;numbersComponent&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;NumbersComponent&lt;/span&gt; {
        NumbersComponent(parent&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;self&lt;/span&gt;)
    }

    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;randomNumbersFetcher&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;any&lt;/span&gt; RandomNumbersFetcherProtocol {
        RandomNumbersFetcher()
    }
}
&lt;/pre&gt;


&lt;p&gt;親子関係を作るために &lt;code&gt;RootComponent&lt;/code&gt; のプロパティとして &lt;code&gt;NumbersComponent&lt;/code&gt; を生成し、 &lt;code&gt;parent&lt;/code&gt; パラメータに自らを渡しています。これで、 needle に &lt;code&gt;RootComponent&lt;/code&gt; が子として &lt;code&gt;NumbersComponent&lt;/code&gt; を持つことが伝わります。&lt;/p&gt;

&lt;p&gt;次に、 &lt;code&gt;NumbersComponent&lt;/code&gt; が必要とする依存である &lt;code&gt;randomNumbersFetcher&lt;/code&gt; をプロパティとして持たせます。 needle の働きにより &lt;code&gt;NumbersDependency&lt;/code&gt; の &lt;code&gt;randomNumbersFetcher&lt;/code&gt; にこの実装が入ってくることになります。今回は &lt;code&gt;RootComponent&lt;/code&gt; と &lt;code&gt;NumbersComponent&lt;/code&gt; に直接の親子関係がありますが、直接の子でなくても子孫であれば先祖が提供する依存を取得することができます。例えば &lt;code&gt;NumbersComponent&lt;/code&gt; の子として &lt;code&gt;NumberDetailComponent&lt;/code&gt; を作ったとして、 &lt;code&gt;NumberDetailComponent&lt;/code&gt; も &lt;code&gt;RootComponent&lt;/code&gt; が提供する &lt;code&gt;randomNumbersFetcher&lt;/code&gt; を &lt;code&gt;Dependency&lt;/code&gt; を通じて利用できるということです。
ただし、依存の提供に関して以下の２点に注意する必要があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提供側（&lt;code&gt;RootComponent&lt;/code&gt;）と受け取り側（&lt;code&gt;NumbersDependency&lt;/code&gt;）は同じプロパティ名で依存を持つ必要がある&lt;/li&gt;
&lt;li&gt;子孫の &lt;code&gt;Component&lt;/code&gt; に依存が渡されるためには提供される依存のアクセスレベルが &lt;code&gt;public&lt;/code&gt; である必要がある&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以上の仕組みを実現するために needle の &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/CLI&quot;&gt;CLI&lt;/a&gt; コマンドを実行してコード生成を行います。以下のコマンドで、 &lt;code&gt;NumbersApp&lt;/code&gt; 以下に存在するコードから &lt;code&gt;Component&lt;/code&gt; の親子関係を読みとって、必要なコードを &lt;code&gt;NumbersApp/NeedleGenerated.swift&lt;/code&gt; に生成してくれます。&lt;/p&gt;

&lt;pre class=&quot;code lang-sh&quot; data-lang=&quot;sh&quot; data-unlink&gt;needle generate NumbersApp/NeedleGenerated.swift NumbersApp/
&lt;/pre&gt;


&lt;p&gt;生成された &lt;code&gt;NeedleGenerated.swift&lt;/code&gt; をプロジェクトに加え、アプリ起動時に &lt;code&gt;registerProviderFactories&lt;/code&gt; という関数を呼ぶことで needle の仕組みが有効になります。&lt;/p&gt;

&lt;p&gt;最後に、 &lt;code&gt;RootComponent&lt;/code&gt; の&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9&quot;&gt;インスタンス&lt;/a&gt;を生成する作業も合わせて、アプリのエンドポイントは以下のようにします。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// NumbersApp.swift&lt;/span&gt;

&lt;span class=&quot;synType&quot;&gt;@main&lt;/span&gt;
&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;NumbersApp&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;App&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;rootComponent&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;RootComponent&lt;/span&gt;

    &lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;() {
        registerProviderFactories()
        &lt;span class=&quot;synIdentifier&quot;&gt;self&lt;/span&gt;.rootComponent &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; RootComponent()
    }

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; Scene {
        WindowGroup {
            rootComponent.numbersComponent.build()
        }
    }
}
&lt;/pre&gt;


&lt;p&gt;これで、アプリが正しく動作するようになりました。実行すると、 &lt;code&gt;rootComponent.numbersComponent&lt;/code&gt; が生成する &lt;code&gt;NumbersScreen&lt;/code&gt; が表示されますが、この &lt;code&gt;NumbersScreen&lt;/code&gt; は &lt;code&gt;RootComponent&lt;/code&gt; が提供する &lt;code&gt;randomNumbersFetcher&lt;/code&gt; を利用することで動作していて、めでたいです。&lt;/p&gt;

&lt;h2 id=&quot;誰がどの依存を提供するか&quot;&gt;誰がどの依存を提供するか&lt;/h2&gt;

&lt;p&gt;今回は &lt;code&gt;RootComponent&lt;/code&gt; に &lt;code&gt;randomNumbersFetcher&lt;/code&gt; を提供してもらいました。これにより、今後 &lt;code&gt;RootComponent&lt;/code&gt; の子孫が増えてもその全員が &lt;code&gt;randomNumbersFetcher&lt;/code&gt; を利用することができるというメリットがあります。しかし、冷静に考えると現段階では &lt;code&gt;randomNumbersFetcher&lt;/code&gt; を使っているのは &lt;code&gt;NumbersScreen&lt;/code&gt; だけなので &lt;code&gt;NumbersComponent&lt;/code&gt; が自ら提供することも可能です。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;NumbersComponent&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;NumbersDependency&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;randomNumbersFetcher&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;any&lt;/span&gt; RandomNumbersFetcherProtocol {
        RandomNumbersFetcher()
    }

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;build&lt;/span&gt;() &lt;span class=&quot;synSpecial&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        NumbersScreen(randomNumbersFetcher&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;randomNumbersFetcher&lt;/span&gt;)
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;Component&lt;/code&gt; のツリーの中で誰がどの依存を提供するかはとくに定められていないので、アプリの都合によって自由に決めることができます。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ここまでで needle を使い始めるにあたって理解しておくべき基本的なことはおおよそ見てこれたと思います。&lt;/p&gt;

&lt;p&gt;needle において理解するべきは &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;Dependency&lt;/code&gt; です。 &lt;code&gt;Component&lt;/code&gt; は &lt;code&gt;BootstrapComponent&lt;/code&gt; をルートとする親子関係のツリーを作ります。個々の &lt;code&gt;Component&lt;/code&gt; は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;子孫が利用する依存の実装を提供する責任&lt;/li&gt;
&lt;li&gt;祖先が提供してくれる依存を &lt;code&gt;Dependency&lt;/code&gt; を利用して画面を作る責任&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;を持ちます。 needle のコード生成により、祖先が提供する依存が子孫の &lt;code&gt;Dependency&lt;/code&gt; に入ってくきます。&lt;/p&gt;

&lt;p&gt;より詳しいことは公式のドキュメントを参照しましょう。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fuber%2Fneedle%2Fblob%2Fmaster%2FAPI.md&quot; title=&quot;needle/API.md at master · uber/needle&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://github.com/uber/needle/blob/master/API.md&quot;&gt;github.com&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
</content>        
        <link rel="enclosure" href="https://cdn.blog.st-hatena.com/images/theme/og-image-1500.png" type="image/png" length="0" />

        <author>
            <name>maiyama4</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>プロパティラッパーによる actor isolation inference が削除される</title>
        <link href="https://maiyama4.hatenablog.com/entry/2023/12/16/110453"/>
        <id>hatenablog://entry/820878482968218534</id>
        <published>2023-12-16T11:04:53+09:00</published>
        <updated>2023-12-16T11:04:53+09:00</updated>        <summary type="html">Swift Advent Calendar 2023 の 15 日目です。 TL;DR 現在の swift にはプロパティラッパーによる actor isolation inference という仕様がある。この仕様のために例えば @StateObject や @ObservedObject を持つ SwiftUI の View が暗黙のうちに @MainActor になるということが起こっている この仕様が分かりにくいということで Swift 6 で削除されることになった デフォルトで削除されるのは Swift 6 からの予定だが、 Swift 5.9 から --enable-upcomin…</summary>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://qiita.com/advent-calendar/2023/swift&quot;&gt;Swift Advent Calendar 2023&lt;/a&gt; の 15 日目です。&lt;/p&gt;

&lt;h2 id=&quot;TLDR&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;現在の swift にはプロパティラッパーによる actor isolation inference という仕様がある。この仕様のために例えば &lt;code&gt;@StateObject&lt;/code&gt; や &lt;code&gt;@ObservedObject&lt;/code&gt; を持つ SwiftUI の View が暗黙のうちに &lt;code&gt;@MainActor&lt;/code&gt; になるということが起こっている&lt;/li&gt;
&lt;li&gt;この仕様が分かりにくいということで Swift 6 で削除されることになった

&lt;ul&gt;
&lt;li&gt;デフォルトで削除されるのは Swift 6 からの予定だが、 Swift 5.9 から &lt;code&gt;--enable-upcoming-feature DisableOutwardActorInference&lt;/code&gt; という&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9&quot;&gt;コンパイラ&lt;/a&gt;フラグで削除を先取りできる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2 id=&quot;actor-isolation-inference-とは&quot;&gt;actor isolation inference とは&lt;/h2&gt;

&lt;p&gt;global actor にはさまざまな推論のルールがあり、ある class や struct に明示的な&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%CE%A5%C6%A1%BC%A5%B7%A5%E7%A5%F3&quot;&gt;アノテーション&lt;/a&gt;がなくても暗黙のうちに global actor に隔離されているということが起こる。例えば、親クラスが global actor に隔離されている場合は子クラスは暗黙のうちに同じ global actor に隔離される。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;@MainActor&lt;/span&gt;
&lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;Parent&lt;/span&gt; {}

&lt;span class=&quot;synComment&quot;&gt;// 暗黙のうちに @MainActor&lt;/span&gt;
&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Parent&lt;/span&gt; {}
&lt;/pre&gt;


&lt;p&gt;このように、明示的に actor になっていない宣言が暗黙のうちに actor に隔離されることを actor isolation inference という。 actor isolation inference にはいくつかのパターンがあり、そのルールは &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/main/proposals/0316-global-actors.md#global-actor-inference&quot;&gt;SE-0316&lt;/a&gt; にまとまっているが、その中の１つにプロパティラッパーに関するものがある。プロパティラッパーの &lt;code&gt;wrappedValue&lt;/code&gt; が global actor に隔離されている場合にそのプロパティラッパーをプロパティにもつ struct や class が同じ global actor に暗黙的に隔離される、というものだ。&lt;/p&gt;

&lt;p&gt;&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%D7%A5%EA%B3%AB%C8%AF&quot;&gt;アプリ開発&lt;/a&gt;をしていると「SwiftUI の View が &lt;code&gt;@StateObject&lt;/code&gt; や &lt;code&gt;@ObservedObject&lt;/code&gt; を持つ場合に View 全体が &lt;code&gt;@MainActor&lt;/code&gt; になる」という形でよくこのルールに出会うことになる。もともと SwiftUI の View 自体は &lt;code&gt;@MainActor&lt;/code&gt; ではない（ View の &lt;code&gt;body&lt;/code&gt; プロパティが &lt;code&gt;@MainActor&lt;/code&gt; ）。しかし、 &lt;code&gt;@StateObject&lt;/code&gt; や &lt;code&gt;@ObservedObject&lt;/code&gt; はその &lt;code&gt;wrappedValue&lt;/code&gt; が &lt;code&gt;@MainActor&lt;/code&gt; なので、 actor isolation inference によりこれらをプロパティとして持つ View 自体が &lt;code&gt;@MainActor&lt;/code&gt; になるということになる。&lt;/p&gt;

&lt;p&gt;以上のことをコードを書いて確かめてみる。ある処理が &lt;code&gt;@MainActor&lt;/code&gt; かどうか確かめる方法に &lt;code&gt;@MainActor&lt;/code&gt; の関数が同期的に呼べるかどうかを見る方法がある。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;@MainActor&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;func&lt;/span&gt; mainActorFunction() {}
&lt;/pre&gt;


&lt;p&gt;これを SwiftUI の View から呼んでみる。以下のように、 &lt;code&gt;body&lt;/code&gt; の中では &lt;code&gt;mainActorFunction&lt;/code&gt; が呼べるのに対して、 &lt;code&gt;f&lt;/code&gt; からは呼べないことがわかる。このことで &lt;code&gt;body&lt;/code&gt; が &lt;code&gt;@MainActor&lt;/code&gt; なのに対して、 &lt;code&gt;SomeView&lt;/code&gt; 自体は &lt;code&gt;@MainActor&lt;/code&gt; ではなく、その&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9&quot;&gt;インスタンス&lt;/a&gt;メソッドの &lt;code&gt;f&lt;/code&gt; も &lt;code&gt;@MainActor&lt;/code&gt; ではないことがわかる。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;SomeView&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        Text(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Some View&amp;quot;&lt;/span&gt;)
            .onAppear {
                &lt;span class=&quot;synComment&quot;&gt;// ✅ body が @MainActor なので OK&lt;/span&gt;
                mainActorFunction()
            }
    }

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;f&lt;/span&gt;() {
        &lt;span class=&quot;synComment&quot;&gt;// SomeView は @MainActor ではないためエラー&lt;/span&gt;
        &lt;span class=&quot;synComment&quot;&gt;// ❌ Call to main actor-isolated global function &#39;mainActorFunction()&#39; in a synchronous nonisolated context&lt;/span&gt;
        mainActorFunction()
    }
}
&lt;/pre&gt;


&lt;p&gt;一方で、以下のように &lt;code&gt;@ObservedObject&lt;/code&gt; をプロパティに持つことにより View 自体が &lt;code&gt;@MainActor&lt;/code&gt; になるため、その&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9&quot;&gt;インスタンス&lt;/a&gt;メソッドからは同期的に &lt;code&gt;mainActorFunction&lt;/code&gt; を呼ぶことができるようになる。これが actor isolation inference によって起こっている。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;SomeViewModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;ObservableObject&lt;/span&gt; {}

&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;SomeViewWithObservedObject&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@ObservedObject&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;var&lt;/span&gt; viewModel&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;SomeViewModel&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        Text(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Some View With ObservedObject&amp;quot;&lt;/span&gt;)
    }

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;f&lt;/span&gt;() {
        &lt;span class=&quot;synComment&quot;&gt;// ✅ actor isolation inference により SomeViewWithObservedObject が @MainActor になっているので OK&lt;/span&gt;
        mainActorFunction()
    }
}
&lt;/pre&gt;


&lt;p&gt;ここで、 &lt;code&gt;SomeViewModel&lt;/code&gt; 自体が &lt;code&gt;@MainActor&lt;/code&gt; であるかどうかは関係ないことには注意が必要。 actor isolation inference が効くかどうかはあくまでプロパティラッパーの &lt;code&gt;wrappedValue&lt;/code&gt; プロパティが global actor に隔離されているかどうかによって決まるので、上記の例だと &lt;code&gt;@ObservedObject&lt;/code&gt; が以下のように定義されている時点で &lt;code&gt;SomeViewModel&lt;/code&gt; が &lt;code&gt;@MainActor&lt;/code&gt; かどうかに関わらず actor isolation inference が効くことになる。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;@frozen&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;@propertyWrapper&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;StateObject&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;ObjectType&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;DynamicProperty&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;where&lt;/span&gt; ObjectType &lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;ObservableObject&lt;/span&gt; {
    &lt;span class=&quot;synComment&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;synType&quot;&gt;@MainActor&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;wrappedValue&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;ObjectType&lt;/span&gt; { &lt;span class=&quot;synStatement&quot;&gt;get&lt;/span&gt; }
}
&lt;/pre&gt;


&lt;h2 id=&quot;actor-isolation-inference-がなぜ必要だったか--なぜ削除されるか&quot;&gt;actor isolation inference がなぜ必要だったか / なぜ削除されるか&lt;/h2&gt;

&lt;p&gt;actor isolation inference は &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md&quot;&gt;SE-0401&lt;/a&gt; にて削除されることになった。 actor isolation inference がそもそもなぜ必要だったかと、せっかく入った仕様がなぜ削除されるのかを見ていく。&lt;/p&gt;

&lt;p&gt;actor isolation inference が仕様に入った理由については、プロポーザルで以下のように述べられている。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The original motivation for this inference rule was to reduce the annotation burden when using property wrappers like SwiftUI&#39;s &lt;code&gt;@ObservedObject&lt;/code&gt; .&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;この &quot;annotation burden&quot; というのは具体的になんなのかを知るために、仮に actor isolation inference の仕様がなかったらどういう負担があったのかを考えたい。 actor isolation inference が削除されるのは Swift 6 からの予定だが、実は Swift 5.9 から &lt;code&gt;--enable-upcoming-feature DisableOutwardActorInference&lt;/code&gt; というフラグをつけることで actor isolation inference の削除を先取りできるようになっている。 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; では、 Build Settings の &lt;code&gt;Other Swift Flags&lt;/code&gt; に以下のような指定をすれば OK。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231008/20231008184011.png&quot; width=&quot;1200&quot; height=&quot;301&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;actor isolation inference を disable した状態で Concurrency 関連のチェックを厳密にするために &lt;a href=&quot;https://qiita.com/maiyama18/items/7f2a7c0ed4cce9d3af72&quot;&gt;Strict Concurrency Checking&lt;/a&gt; を &lt;code&gt;Complete&lt;/code&gt; にすると、例えば以下のような&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB&quot;&gt;コンパイル&lt;/a&gt;エラーが発生する。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;SomeViewModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;ObservableObject&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;someMethod&lt;/span&gt;() {}
}

&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;SomeViewWithObservedObject&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@ObservedObject&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;var&lt;/span&gt; viewModel&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;SomeViewModel&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        Text(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Some View With ObservedObject&amp;quot;&lt;/span&gt;)
    }

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;f&lt;/span&gt;() {
        &lt;span class=&quot;synComment&quot;&gt;// ❌ Main actor-isolated property &#39;viewModel&#39; can not be referenced from a non-isolated context&lt;/span&gt;
        viewModel.someMethod()
    }
}
&lt;/pre&gt;


&lt;p&gt;actor isolation inference がないため &lt;code&gt;SomeViewWithObservedObject&lt;/code&gt; は&lt;code&gt;@MainActor&lt;/code&gt; ではない。そのため &lt;code&gt;@ObservedObject&lt;/code&gt; の &lt;code&gt;wrappedValue&lt;/code&gt; であることで &lt;code&gt;@MainActor&lt;/code&gt; になっている &lt;code&gt;viewModel&lt;/code&gt; プロパティに同期的に触れなくなるということが起こっている。この例に限らず、 View が &lt;code&gt;@ObservedObject&lt;/code&gt; をプロパティとして持つからには当然&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9&quot;&gt;インスタンス&lt;/a&gt;メソッドで &lt;code&gt;@ObservedObject&lt;/code&gt; の &lt;code&gt;wrappedValue&lt;/code&gt; を操作したいことが多く、 View が &lt;code&gt;@MainActor&lt;/code&gt; でない場合には同期的に触れなくていちいち困ることになる。その対策として &lt;code&gt;SomeView&lt;/code&gt; 自体に &lt;code&gt;@MainActor&lt;/code&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%CE%A5%C6%A1%BC%A5%B7%A5%E7%A5%F3&quot;&gt;アノテーション&lt;/a&gt;をつければ OK だが、いちいちそれをする &quot;annotation burden&quot; を省くためにこれまで actor isolation inference が自動的に &lt;code&gt;SomeView&lt;/code&gt; を &lt;code&gt;@MainActor&lt;/code&gt; にしてくれていたというわけだ。&lt;/p&gt;

&lt;p&gt;そんな親切心から実装された actor isolation inference が削除されることになった理由だが、暗黙的で予期しない振る舞いである割にメリットが小さいためだと &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md&quot;&gt;SE-0401&lt;/a&gt; やそれに関連する議論で言われている。&lt;/p&gt;

&lt;p&gt;「SwiftUI の View は本来 &lt;code&gt;@MainActor&lt;/code&gt; ではないが &lt;code&gt;@StateObject&lt;/code&gt; や &lt;code&gt;@ObservedObject&lt;/code&gt; をプロパティとして持った瞬間に &lt;code&gt;@MainActor&lt;/code&gt; になる」というのはたしかにわかりづらい挙動に思える。この仕様のせいで SwiftUI の View 自体が本来的に &lt;code&gt;@MainActor&lt;/code&gt; であるというたぐいの誤解も生まれているかもしれない。その上で、 actor isolation inference が省いてくれる手間は &lt;code&gt;@MainActor&lt;/code&gt; という&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%CE%A5%C6%A1%BC%A5%B7%A5%E7%A5%F3&quot;&gt;アノテーション&lt;/a&gt;を書く部分のみなので、それなら&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE&quot;&gt;プログラマ&lt;/a&gt;が明示的な &lt;code&gt;@MainActor&lt;/code&gt; をつける方がいいじゃんというのは、なかなかうなずける話だと思う。 &lt;a href=&quot;https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md&quot;&gt;SE-0401&lt;/a&gt; のレビュースレッドにも、賛同のコメントがどんどん寄せられている。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fforums.swift.org%2Ft%2Fse-0401-remove-actor-isolation-inference-caused-by-property-wrappers%2F65618&quot; title=&quot;SE-0401: Remove Actor Isolation Inference caused by Property Wrappers&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://forums.swift.org/t/se-0401-remove-actor-isolation-inference-caused-by-property-wrappers/65618&quot;&gt;forums.swift.org&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;h2 id=&quot;actor-isolation-inference-削除への対応&quot;&gt;actor isolation inference 削除への対応&lt;/h2&gt;

&lt;p&gt;そもそも、 actor isolation inference が削除されるのは Swift 6 からという予定になっているので、 Swift 6 が利用できるようになってから対応するのでも大丈夫だと思う。ただ、 Swift 5.9 以降では &lt;code&gt;--enable-upcoming-feature DisableOutwardActorInference&lt;/code&gt; をつけて対応を先取りするということもできる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-enable-upcoming-feature DisableOutwardActorInference&lt;/code&gt; を&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9&quot;&gt;コンパイラ&lt;/a&gt;フラグに追加することでこれまで actor isolation inference のおかげで推論が効いて暗黙的に global actor になっていた箇所の中で&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB&quot;&gt;コンパイル&lt;/a&gt;エラーが出る箇所があるので、対応としてはそのエラーを自分で global actor の&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%CE%A5%C6%A1%BC%A5%B7%A5%E7%A5%F3&quot;&gt;アノテーション&lt;/a&gt;をつけることで直してまわれば大丈夫だと思う。つまり、これまで&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9&quot;&gt;コンパイラ&lt;/a&gt;がやってくれていたことを自分でやり直すということだ。&lt;/p&gt;

&lt;p&gt;ただ、重要な注意点として、 actor isolation inference を外すことによる&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB&quot;&gt;コンパイル&lt;/a&gt;エラーは Strict Concurrency Checking の設定が &lt;code&gt;Complete&lt;/code&gt; 以外の状態では出ないことがある。実際に、先ほど Strict Concurrency Checking が &lt;code&gt;Complete&lt;/code&gt; で&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB&quot;&gt;コンパイル&lt;/a&gt;エラーが出たコードでも、 &lt;code&gt;Targeted&lt;/code&gt; やデフォルトの &lt;code&gt;Minimal&lt;/code&gt; に設定するとエラーが出ない。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;SomeViewWithObservedObject&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@ObservedObject&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;var&lt;/span&gt; viewModel&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;SomeViewModel&lt;/span&gt;

    &lt;span class=&quot;synComment&quot;&gt;// ...&lt;/span&gt;

     &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;f&lt;/span&gt;() {
        &lt;span class=&quot;synComment&quot;&gt;// ⚠️ -enable-upcoming-feature DisableOutwardActorInference していても&lt;/span&gt;
        &lt;span class=&quot;synComment&quot;&gt;// ⚠️ Strict Concurrency Checking が Minimal / Targeted の場合はコンパイルエラーにならない&lt;/span&gt;
        viewModel.someMethod()
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB&quot;&gt;コンパイル&lt;/a&gt;エラーが出ないということは、動作が変わっても気づけない可能性があるということだ。この例ではこれまで &lt;code&gt;viewModel.someMethod()&lt;/code&gt; はメインスレッドから呼ばれていたが、 global actor inference が外れることでバックグラウンドスレッドから呼ばれることがあり得るため、予期しない動作につながるかもしれない。これを避けるために、先取りで &lt;code&gt;--enable-upcoming-feature DisableOutwardActorInference&lt;/code&gt; をつけるのは Strict Concurrency Checking を &lt;code&gt;Complete&lt;/code&gt; に変更してからの方がよいかもしれない。&lt;/p&gt;
</content>        
        <link rel="enclosure" href="https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20230918/20230918173303.png" type="image/png" length="0" />

        <author>
            <name>maiyama4</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>iOS アプリのマルチモジュール開発とインターフェースモジュール</title>
        <link href="https://maiyama4.hatenablog.com/entry/2023/12/13/184702"/>
        <id>hatenablog://entry/6801883189065085500</id>
        <published>2023-12-13T18:47:02+09:00</published>
        <updated>2023-12-13T18:51:21+09:00</updated>        <summary type="html">この記事は はてなエンジニア Advent Calendar 2023 の 13 日目です。 昨日は シンプルで使いやすいマイクロHTTPフレームワーク『Cask』を紹介するよ - Lambdaカクテル でした。 Scala にもこういう入りやすそうなフレームワークがあるんですね。easy で fun なツールをどんどん使っていきたいし、人生も easy で fun になってほしい。 今日は iOS アプリについて書きます。 概要 アプリケーションを継続的に開発していくことで、コードベースもどんどん大きくなっていきます。とくに iOS アプリではコードベースが大きくなることにより、ビルド時間が…</summary>
        <content type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://developer.hatenastaff.com/advent-calendar-2023&quot;&gt;はてなエンジニア Advent Calendar 2023&lt;/a&gt; の 13 日目です。&lt;/p&gt;

&lt;p&gt;昨日は &lt;a href=&quot;https://blog.3qe.us/entry/2023/12/12/193359&quot;&gt;&amp;#x30B7;&amp;#x30F3;&amp;#x30D7;&amp;#x30EB;&amp;#x3067;&amp;#x4F7F;&amp;#x3044;&amp;#x3084;&amp;#x3059;&amp;#x3044;&amp;#x30DE;&amp;#x30A4;&amp;#x30AF;&amp;#x30ED;HTTP&amp;#x30D5;&amp;#x30EC;&amp;#x30FC;&amp;#x30E0;&amp;#x30EF;&amp;#x30FC;&amp;#x30AF;&amp;#x300E;Cask&amp;#x300F;&amp;#x3092;&amp;#x7D39;&amp;#x4ECB;&amp;#x3059;&amp;#x308B;&amp;#x3088; - Lambda&amp;#x30AB;&amp;#x30AF;&amp;#x30C6;&amp;#x30EB;&lt;/a&gt; でした。 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Scala&quot;&gt;Scala&lt;/a&gt; にもこういう入りやすそうな&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF&quot;&gt;フレームワーク&lt;/a&gt;があるんですね。easy で fun なツールをどんどん使っていきたいし、人生も easy で fun になってほしい。&lt;/p&gt;

&lt;p&gt;今日は &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; アプリについて書きます。&lt;/p&gt;

&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;

&lt;p&gt;アプリケーションを継続的に開発していくことで、コードベースもどんどん大きくなっていきます。とくに &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; アプリではコードベースが大きくなることにより、ビルド時間が長くなってしまい開発効率が悪くなってしまうことがあります。&lt;/p&gt;

&lt;p&gt;機能とともにアプリのサイズが増えるのは自然なことなので、その問題への対応としてアプリ自体のサイズを小さくする...というのはなかなか難しいです。しかし、アプリを細かいモジュールに分けて、小さい単位で開発していくことはできます。モジュール化によりビルドの範囲がアプリ全体からモジュールに小さくなることで、高速にビルド・テスト・プレビューなどが行えるため、より効率的に&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%D7%A5%EA%B3%AB%C8%AF&quot;&gt;アプリ開発&lt;/a&gt;をしていくことができます。&lt;/p&gt;

&lt;p&gt;この記事では、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;アプリのマルチモジュール化&lt;/li&gt;
&lt;li&gt;インターフェースモジュールの導入&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;によってテストやプレビューが高速化でき、効率よく&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%A2%A5%D7%A5%EA%B3%AB%C8%AF&quot;&gt;アプリ開発&lt;/a&gt;が進められる様子をサンプルアプリを開発しながら見ていこうと思います。&lt;/p&gt;

&lt;p&gt;マルチモジュール開発については自分も試行錯誤しているところであり、この記事には勘違いや改善点が含まれているかもしれません。コメントや &lt;a href=&quot;https://twitter.com/_maiyama18&quot;&gt;twitter&lt;/a&gt; で教えていただけるととても助かります。&lt;/p&gt;

&lt;p&gt;この記事のための検証は &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; 15.1 で行っています。&lt;/p&gt;

&lt;h2 id=&quot;サンプル--カウンターアプリ&quot;&gt;サンプル : カウンターアプリ&lt;/h2&gt;

&lt;p&gt;サンプルとして、以下のようなボタンを押してカウントをインクリメントするだけの単純なアプリを考えます。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231208/20231208143322.gif&quot; width=&quot;560&quot; height=&quot;1200&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:300px&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;アプリの名前は &lt;code&gt;SampleApp&lt;/code&gt; とします。 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; を開いてプロジェクトを作成し、カウンターの画面を &lt;code&gt;CounterScreen&lt;/code&gt; として実装します。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// SampleApp.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; SwiftUI

&lt;span class=&quot;synType&quot;&gt;@main&lt;/span&gt;
&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;SampleApp&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;App&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; Scene {
        WindowGroup {
            CounterScreen()
        }
    }
}
&lt;/pre&gt;




&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// CounterScreen.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; Combine
&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; SwiftUI

&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CounterViewModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;ObservableObject&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@Published&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;private&lt;/span&gt;(&lt;span class=&quot;synStatement&quot;&gt;set&lt;/span&gt;) &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;increment&lt;/span&gt;() {
        count &lt;span class=&quot;synIdentifier&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;
    }
}

&lt;span class=&quot;synPreProc&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CounterScreen&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;View&lt;/span&gt; {
    &lt;span class=&quot;synType&quot;&gt;@StateObject&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterViewModel&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;()

    &lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;() {}

    &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;some&lt;/span&gt; View {
        VStack {
            Text(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;viewModel.count&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;)
                .monospacedDigit()

            Button(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;) {
                viewModel.increment()
            }
        }
        .font(.largeTitle)
    }
}
&lt;/pre&gt;


&lt;h2 id=&quot;Feature-モジュールを切り分ける&quot;&gt;Feature モジュールを切り分ける&lt;/h2&gt;

&lt;p&gt;この時点ではコードはすべて &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; プロジェクトに入っている状態です。これをモジュールに分割していくことにします。 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; アプリにおいては、例えば &lt;a href=&quot;https://github.com/pointfreeco/isowords&quot;&gt;pointfreeco/isowords&lt;/a&gt; で行われているように、画面ごとあるいは関連する画面のまとまりごとに Feature モジュールを切る方法がよくとられていると思います。&lt;/p&gt;

&lt;p&gt;カウンターアプリには画面が１つしかありませんが、そのカウンター画面を Feature モジュールに切り分けることにします。モジュール分割の実現方法として、今回は swift package を作成してその中に &lt;code&gt;CounterFeature&lt;/code&gt; モジュールを切り、 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; プロジェクトから依存することにします。
swift package は &lt;code&gt;SampleAppPackage&lt;/code&gt; という名前で作成し、 &lt;code&gt;Package.swift&lt;/code&gt; は以下のようにします。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// swift-tools-version: 5.9&lt;/span&gt;
&lt;span class=&quot;synComment&quot;&gt;// The swift-tools-version declares the minimum version of Swift required to build this package.&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; PackageDescription

&lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; Package(
    name&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;SampleAppPackage&amp;quot;&lt;/span&gt;,
    platforms&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;.iOS&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;.v17&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)]&lt;/span&gt;,
    products&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;
&lt;span class=&quot;synType&quot;&gt;        .library&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;name: &amp;quot;CounterFeature&amp;quot;&lt;/span&gt;,&lt;span class=&quot;synType&quot;&gt; targets: &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;&amp;quot;CounterFeature&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;synType&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;]&lt;/span&gt;,
    targets&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;
&lt;span class=&quot;synType&quot;&gt;        .target&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;name: &amp;quot;CounterFeature&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;synType&quot;&gt;        .testTarget&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;name: &amp;quot;CounterFeatureTests&amp;quot;&lt;/span&gt;,&lt;span class=&quot;synType&quot;&gt; dependencies: &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;&amp;quot;CounterFeature&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;synType&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;]&lt;/span&gt;
)
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;SampleAppPackage&lt;/code&gt; を &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; プロジェクトに追加し、 &lt;code&gt;SampleApp&lt;/code&gt; ターゲットの &lt;code&gt;Framework, Libraries and Embedded Content&lt;/code&gt; にて &lt;code&gt;CounterFeature&lt;/code&gt; をリンクします。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231208/20231208145711.png&quot; width=&quot;1200&quot; height=&quot;274&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CounterScreen.swift&lt;/code&gt; を &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; プロジェクトから &lt;code&gt;CounterFeature&lt;/code&gt; の中に移動します。 &lt;code&gt;CounterScreen&lt;/code&gt; は &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; プロジェクト内、すなわち &lt;code&gt;CounterFeature&lt;/code&gt; 外の &lt;code&gt;SampleApp.swift&lt;/code&gt; から利用できるようにする必要があるため、アクセスレベルを &lt;code&gt;public&lt;/code&gt; にしておきます。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// CounterFeature/CounterScreen.swift

&lt;span class=&quot;synSpecial&quot;&gt;- struct CounterScreen: View {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+ public struct CounterScreen: View {&lt;/span&gt;
    @StateObject private var viewModel: CounterViewModel = .init()

&lt;span class=&quot;synSpecial&quot;&gt;-   init() {}&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   public init() {}&lt;/span&gt;

&lt;span class=&quot;synSpecial&quot;&gt;-   var body: some View {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   public var body: some View {&lt;/span&gt;
        // ...
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;SampleApp.swift&lt;/code&gt; の方では &lt;code&gt;CounterScreen&lt;/code&gt; を利用するために &lt;code&gt;CounterFeature&lt;/code&gt; を import します。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;import SwiftUI
&lt;span class=&quot;synIdentifier&quot;&gt;+ import CounterFeature&lt;/span&gt;

// ...
&lt;/pre&gt;


&lt;p&gt;以上で、カウンター画面を Feature モジュールに切り分けることができました。&lt;/p&gt;

&lt;h2 id=&quot;テストとプレビューを追加する&quot;&gt;テストとプレビューを追加する&lt;/h2&gt;

&lt;p&gt;アプリ全体を毎回ビルドしなくても開発が進められるようにするための道具として、テストとプレビューを追加します。&lt;/p&gt;

&lt;p&gt;すでにテスト用に &lt;code&gt;CounterFeatureTests&lt;/code&gt; ターゲットがあるので、そこにカウンターのロジックを確認する以下のようなテストを追加しておきましょう。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// CounterFeatureTests/CounterViewModelTests.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; XCTest
&lt;span class=&quot;synType&quot;&gt;@testable&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;import&lt;/span&gt; CounterFeature

&lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;CounterViewModelTests&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;XCTestCase&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;testIncrement&lt;/span&gt;() {
        &lt;span class=&quot;synPreProc&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;CounterViewModel&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; .&lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;()

        XCTAssertEqual(viewModel.count, &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;)
        viewModel.increment()
        XCTAssertEqual(viewModel.count, &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;)
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;SampleApp&lt;/code&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE&quot;&gt;スキーマ&lt;/a&gt;のテストプランに &lt;code&gt;CounterFeatureTests&lt;/code&gt; を追加することで、テストが実行できるようになります。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209005417.png&quot; width=&quot;1200&quot; height=&quot;292&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;続いて、プレビューも追加します。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// CounterFeature/CounterScreen.swift

// ...

&lt;span class=&quot;synIdentifier&quot;&gt;+ #Preview {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+     CounterScreen()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+ }&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;プレビューにより、コードの変更がアプリの画面にどのように反映されるかを明示的なビルドなしで確認することができます。タップなどのインタ&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%E9%A5%AF&quot;&gt;ラク&lt;/a&gt;ションも有効になっているので、以下のように試行錯誤しつつ UI を開発していくことができます。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209011417.gif&quot; width=&quot;1200&quot; height=&quot;748&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;この時点で、プロジェクト構成は以下のようになっています。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231208/20231208150441.png&quot; width=&quot;548&quot; height=&quot;718&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:300px&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;ビルドの範囲をモジュールに狭める&quot;&gt;ビルドの範囲をモジュールに狭める&lt;/h2&gt;

&lt;p&gt;実は、現状だとテストやプレビュー時にアプリ全体のビルドが走ってしまっているという問題があります。&lt;/p&gt;

&lt;p&gt;例えば、プレビュー時に走るビルドのタイムラインを見てみると以下のようになっています。 &lt;code&gt;CounterScreen&lt;/code&gt; のプレビューをしたいだけなのに、関係のない &lt;code&gt;SampleApp.swift&lt;/code&gt; もビルドされてしまっていることがわかります。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209013904.png&quot; width=&quot;1200&quot; height=&quot;918&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;アプリの規模が小さいうちはアプリ全体をビルドしても大した問題にならないのですが、アプリが成長していくにつれてビルド時間がどんどん長くなっていくことが予想されます。一度プレビューが表示されてしまえばその後は差分ビルドが効くので初回ビルドと比べて速くなりますが、プレビューにおいてビルドするものが増えていくとそもそもプレビューの動作自体が不安定になることがあるのと、 &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/iOS&quot;&gt;iOS&lt;/a&gt; 開発においては様々な原因でビルドをクリーンして初回ビルドからやり直さなければならないことがあるため、ビルド範囲を狭められるとうれしいです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CounterFeature&lt;/code&gt; のテストやプレビューを実行するためには、アプリ全体ではなく &lt;code&gt;CounterFeature&lt;/code&gt; モジュールのビルドをすれば十分なので、そのような方式に変更していきます。&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; の上部の&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE&quot;&gt;スキーマ&lt;/a&gt;から &lt;code&gt;New Scheme...&lt;/code&gt; をクリックして、&lt;code&gt;CounterFeature&lt;/code&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE&quot;&gt;スキーマ&lt;/a&gt;を追加します（設定によっては自動的に追加されています）。また、 &lt;code&gt;SampleApp&lt;/code&gt; のテストプランと同様に、 &lt;code&gt;CounterFeature&lt;/code&gt; のテストプランにも &lt;code&gt;CounterFeature&lt;/code&gt; を追加しておきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CounterFeature&lt;/code&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE&quot;&gt;スキーマ&lt;/a&gt;をアクティブにした状態で再度プレビューを表示してみると、ビルドタイムラインは以下のようになりました。ビルドの対象から &lt;code&gt;SampleApp.swift&lt;/code&gt; が消え、プレビューに必要な &lt;code&gt;CounterScreen.swift&lt;/code&gt; のビルドのみが実行されるようになっていることがわかります。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209015545.png&quot; width=&quot;1200&quot; height=&quot;785&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;テストに関しても同様のメリットがあります。 &lt;code&gt;CounterFeature&lt;/code&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE&quot;&gt;スキーマ&lt;/a&gt;をアクティブにして cmd+U を押してテストを実行することにより、 &lt;code&gt;CounterViewModelTests&lt;/code&gt; のテストのために走るビルドの範囲が &lt;code&gt;CounterFeature&lt;/code&gt; モジュールのみになっており、ビルド時間の削減ができています。&lt;/p&gt;

&lt;p&gt;カウンター画面に変更した際にその振る舞いや UI の変化を確認するため、アプリを実行したり、プレビューを表示したり、テストを実行したりすると思いますが、モジュール化されていないアプリではいずれにしてもアプリ全体をビルドする必要があります。しかし、上記でモジュール化したサンプルアプリでは、 &lt;code&gt;CounterFeature&lt;/code&gt; の動作確認が &lt;code&gt;CounterFeature&lt;/code&gt; のみをビルドするテストやプレビューで行えます。
これにより、アプリ全体が大きくなっていっても、 Feature モジュールはテストやプレビューから高速なフィードバックを受けつつ開発をしていくことができます。&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE&quot;&gt;スキーマ&lt;/a&gt;を切り替える手間があったり、テストプランをモジュールごとに作らないといけなかったりなどのデメリットもあるため、このやり方が常に最高！というわけではないのですが、ある程度以上の大きさのアプリではメリットの方が大きい場合が多いと思っています。&lt;/p&gt;

&lt;h2 id=&quot;ライブラリに依存する&quot;&gt;ライブラリに依存する&lt;/h2&gt;

&lt;p&gt;ほとんどのアプリでは開発が進むうちに何らかの&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B5%A1%BC%A5%C9%A5%D1%A1%BC%A5%C6%A5%A3&quot;&gt;サードパーティ&lt;/a&gt;ライブラリに依存することになります。ここからは、ライブラリ依存がある場合のマルチモジュール開発について考えていきます。今回は、よくある例として Firebase への依存を追加することにしましょう。開発者として、アプリのカウンターをユーザがちゃんとインクリメントしてくれているかを知りたいので、カウントが 10 になったらその旨を Firebase Analytics に送信することにします。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Package.swift&lt;/code&gt; から Firebase の &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/SDK&quot;&gt;SDK&lt;/a&gt; を依存として追加します。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// Package.swift

let package = Package(
    // ...
&lt;span class=&quot;synIdentifier&quot;&gt;+   dependencies: [&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       .package(url: &amp;quot;https://github.com/firebase/firebase-ios-sdk.git&amp;quot;, exact: &amp;quot;10.19.0&amp;quot;),&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   ],&lt;/span&gt;
    targets: [
        .target(
            name: &amp;quot;CounterFeature&amp;quot;,
&lt;span class=&quot;synIdentifier&quot;&gt;+           dependencies: [.product(name: &amp;quot;FirebaseAnalytics&amp;quot;, package: &amp;quot;firebase-ios-sdk&amp;quot;)]&lt;/span&gt;
        ),
        .testTarget(name: &amp;quot;CounterFeatureTests&amp;quot;, dependencies: [&amp;quot;CounterFeature&amp;quot;]),
    ]
)
&lt;/pre&gt;


&lt;p&gt;実際に Firebase Analytics を使うためには &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/Xcode&quot;&gt;Xcode&lt;/a&gt; プロジェクトや Firebase コンソールからいくつかの設定をする必要がありますが、この記事の本題には関係がないのでここではすべてがよしなに設定されているとして &lt;code&gt;CounterFeature&lt;/code&gt; にて必要な差分のみ示します。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;import Combine
import SwiftUI
&lt;span class=&quot;synIdentifier&quot;&gt;+ import FirebaseAnalytics&lt;/span&gt;

final class CounterViewModel: ObservableObject {
    @Published private(set) var count: Int = 0
    
    func increment() {
        count += 1
&lt;span class=&quot;synIdentifier&quot;&gt;+       if count == 10 {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           Analytics.logEvent(&amp;quot;count10&amp;quot;, parameters: nil)&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       }&lt;/span&gt;
    }
}

public struct CounterScreen: View {
    // ...
}
&lt;/pre&gt;


&lt;p&gt;これで、カウントが 10 に達したときにイベントを送れるようになりました。&lt;/p&gt;

&lt;p&gt;しかし、現状の実装には問題点もあります。&lt;/p&gt;

&lt;p&gt;１つ目の問題は、 &lt;code&gt;CounterViewModel&lt;/code&gt; の中に Firebase にイベントを送るコードが直書きされているため、イベントが送られることをテストする手段がないことです。このままだとイベントが送信の確認のためにアプリを実行して Firebase コンソールを見にいく必要がありますが、手間がかかるし、確認を忘れてイベントが送られなくなってしまう&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%C7%A5%B0%A5%EC&quot;&gt;デグレ&lt;/a&gt;が発生するリスクもあります。&lt;/p&gt;

&lt;p&gt;２つ目の問題は、依存の追加により &lt;code&gt;CounterFeature&lt;/code&gt; をビルドするために Firebase のビルドが必要になり、プレビューやテストが遅く、不安定になってしまっていることです。 &lt;code&gt;CounterScreen&lt;/code&gt; のプレビューを表示したときのビルドタイムラインを見ると、以下のように Firebase がビルドされてしまっていることがわかります。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209034204.png&quot; width=&quot;1200&quot; height=&quot;713&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;イベント送信の実装に Firebase を利用しているということはアプリの動作や UI に関係ないので、本来テストやプレビューのために Firebase をビルドする必要はないはずです。せっかくモジュール分割をしてビルド範囲を狭めたので、依存を追加するたびにビルドする対象が増えてしまうのはできれば避けたいです。&lt;/p&gt;

&lt;p&gt;これから、上記２つの問題に対処していきます。&lt;/p&gt;

&lt;h2 id=&quot;依存をモジュールに切り出す&quot;&gt;依存をモジュールに切り出す&lt;/h2&gt;

&lt;p&gt;まずは、イベント送信を&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8&quot;&gt;ユニットテスト&lt;/a&gt;できるようにします。現状テストができない原因は &lt;code&gt;CounterViewModel&lt;/code&gt; に直接 Firebase のコードを書いていることなので、イベント送信の実装を抜き出して &lt;code&gt;CounterViewModel&lt;/code&gt; に DI することにします。&lt;/p&gt;

&lt;p&gt;そのために、イベント送信のロジックをまとめた &lt;code&gt;AnalyticsService&lt;/code&gt; というモジュールを新たに切ることにします。 &lt;code&gt;Package.swift&lt;/code&gt; を以下のように変更します。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// Package.swift

let package = Package(
    // ...
    targets: [
        .target(
            name: &amp;quot;CounterFeature&amp;quot;,
&lt;span class=&quot;synSpecial&quot;&gt;-           dependencies: [.product(name: &amp;quot;FirebaseAnalytics&amp;quot;, package: &amp;quot;firebase-ios-sdk&amp;quot;)]&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           dependencies: [&amp;quot;Analytics&amp;quot;]&lt;/span&gt;
        ),
        .testTarget(name: &amp;quot;CounterFeatureTests&amp;quot;, dependencies: [&amp;quot;CounterFeature&amp;quot;]),
&lt;span class=&quot;synIdentifier&quot;&gt;+       .target(&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           name: &amp;quot;Analytics&amp;quot;,&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           dependencies: [.product(name: &amp;quot;FirebaseAnalytics&amp;quot;, package: &amp;quot;firebase-ios-sdk&amp;quot;)]&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       ),&lt;/span&gt;
    ]
)
&lt;/pre&gt;


&lt;p&gt;Firebase のロジックをまとめる &lt;code&gt;Analytics&lt;/code&gt; モジュールを追加し、 &lt;code&gt;CounterFeature&lt;/code&gt; からは Firebase ではなく &lt;code&gt;Analytics&lt;/code&gt; に依存するようにしています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Analytics&lt;/code&gt; モジュールの実装をしていきます。まず、イベント送信を抽象化した&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB&quot;&gt;プロトコル&lt;/a&gt;として、 &lt;code&gt;AnalyticsService&lt;/code&gt; を切ります。その具体的な実装として、アプリ実行時に利用される実際に Firebase へのイベント送信を行う &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; と、&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8&quot;&gt;ユニットテスト&lt;/a&gt;にて実行されたイベント送信を検証するための &lt;code&gt;AnalyticsServiceMock&lt;/code&gt; を作ります。&lt;/p&gt;

&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// Analytics/AnalyticsService.swift&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; FirebaseAnalytics

&lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;AnalyticsService&lt;/span&gt; {
    &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;log&lt;/span&gt;(event&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt;)
}

&lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;AnalyticsServiceLive&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;AnalyticsService&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;() {}

    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;log&lt;/span&gt;(event&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt;) {
        Analytics.logEvent(event, parameters&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;nil&lt;/span&gt;)
    }
}

&lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;AnalyticsServiceMock&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;AnalyticsService&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;loggedEvents&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synSpecial&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;=&lt;/span&gt; []

    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;() {}

    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;log&lt;/span&gt;(event&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt;) {
        loggedEvents.append(event)
    }
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;CounterFeature&lt;/code&gt; 側では、 Firebase を直&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%C0%DC%BF%A8&quot;&gt;接触&lt;/a&gt;っていた箇所を &lt;code&gt;AnalyticsService&lt;/code&gt; を利用するように書き換えます。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// CounterFeature/CounterScreen.swift

import Combine
import SwiftUI
&lt;span class=&quot;synSpecial&quot;&gt;- import FirebaseAnalytics&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+ import Analytics&lt;/span&gt;

final class CounterViewModel: ObservableObject {
    // ...

&lt;span class=&quot;synIdentifier&quot;&gt;+   private let analyticsService: any AnalyticsService&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   init(analyticsService: any AnalyticsService) {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       self.analyticsService = analyticsService&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   }&lt;/span&gt;

    func increment() {
        count += 1
        if count == 10 {
&lt;span class=&quot;synSpecial&quot;&gt;-           Analytics.logEvent(&amp;quot;count10&amp;quot;, parameters: nil)&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           analyticsService.log(event: &amp;quot;count10&amp;quot;)&lt;/span&gt;
        }
    }
}

public struct CounterScreen: View {
&lt;span class=&quot;synSpecial&quot;&gt;-   @StateObject private var viewModel: CounterViewModel = .init()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   @StateObject private var viewModel: CounterViewModel = .init(analyticsService: AnalyticsServiceLive())&lt;/span&gt;

    // ...
}
&lt;/pre&gt;


&lt;p&gt;以上の変更をもとに、 &lt;code&gt;CounterViewModel&lt;/code&gt; のイベント送信ロジックのテストを書いていきます。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// CounterFeatureTests/CounterViewModelTests.swift

&lt;span class=&quot;synIdentifier&quot;&gt;+ import Analytics&lt;/span&gt;
import XCTest
&lt;span class=&quot;synStatement&quot;&gt;@testable import CounterFeature&lt;/span&gt;


final class CounterViewModelTests: XCTestCase {
    func testIncrement() {
&lt;span class=&quot;synSpecial&quot;&gt;-       let viewModel: CounterViewModel = .init()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       let viewModel: CounterViewModel = .init(analyticsService: AnalyticsServiceMock())&lt;/span&gt;

        // ...
    }

&lt;span class=&quot;synIdentifier&quot;&gt;+   func testCount10Event() {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       let analyticsService = AnalyticsServiceMock()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       let viewModel: CounterViewModel = .init(analyticsService: analyticsService)&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       for _ in 0..&amp;lt;9 {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           viewModel.increment()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       }&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       XCTAssertEqual(analyticsService.loggedEvents, [])&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       viewModel.increment()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       XCTAssertEqual(analyticsService.loggedEvents, [&amp;quot;count10&amp;quot;])&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   }&lt;/span&gt;
}
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;AnalyticsService&lt;/code&gt; を &lt;code&gt;AnalyticsServiceMock&lt;/code&gt; に差し替えることで、適切なタイミングで &lt;code&gt;&quot;count10&quot;&lt;/code&gt; イベントが送信されることが確認できるようになりました。&lt;/p&gt;

&lt;p&gt;Feature モジュールが Firebase のような具体的なライブラリを直接操作するのではなく、ライブラリをラップしたモジュールを介して操作するようにすることで、アプリ内のロジックのテストを書くことが可能になります。現状だと、 &lt;code&gt;Analytics&lt;/code&gt; モジュールを切らなくても &lt;code&gt;CounterFeature&lt;/code&gt; 内に &lt;code&gt;AnalyticsService&lt;/code&gt; / &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; / &lt;code&gt;AnalyticsServiceMock&lt;/code&gt; を実装してしまうことで同じことが実現可能ですが、これから他の Feature モジュールからもイベント送信をしたくなることを考えると、モジュールを切る方がよさそうなことがわかります。&lt;/p&gt;

&lt;h2 id=&quot;インターフェースモジュールを導入する&quot;&gt;インターフェースモジュールを導入する&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Analytics&lt;/code&gt; モジュールを切ったことにより、 &lt;code&gt;CounterFeature&lt;/code&gt; はイベント送信の実装が Firebase によって行われていることを知らなくてよくなり、イベント送信ロジックのテストが可能になりました。しかし、 &lt;code&gt;CounterFeature&lt;/code&gt; のプレビューを表示しようとすると、相変わらず Firebase をビルドしてしまっています。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209132439.png&quot; width=&quot;1200&quot; height=&quot;704&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;これは、以下の図のように &lt;code&gt;CounterFeature&lt;/code&gt; モジュールが &lt;code&gt;Analytics&lt;/code&gt; モジュールを介して間接的に Firebase に依存しているためです。間接的であっても依存関係がある限りは、 &lt;code&gt;CounterFeature&lt;/code&gt; のビルドのために Firebase のビルドが必要になってしまいます。&lt;/p&gt;

&lt;pre class=&quot;code mermaid&quot; data-lang=&quot;mermaid&quot; data-unlink&gt;graph LR
    classDef default font-family:monospace;
    CounterFeature --&amp;gt; Analytics
    Analytics --&amp;gt; Firebase&lt;/pre&gt;


&lt;p&gt;ロジック上は &lt;code&gt;CounterFeature&lt;/code&gt; が Firebase を知らなくてよい状態になっているので、モジュールの依存関係においても &lt;code&gt;CounterFeature&lt;/code&gt; と Firebase を切り離すことができます。そのために、 &lt;code&gt;AnalyticsService&lt;/code&gt; モジュールを、インターフェースモジュールと実装モジュールに分割します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CounterFeature&lt;/code&gt; のテストやプレビューを行う上で必要なのは、 &lt;code&gt;AnalyticsService&lt;/code&gt; &lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB&quot;&gt;プロトコル&lt;/a&gt;と &lt;code&gt;AnalyticsServiceMock&lt;/code&gt; クラスのみで、それらはいずれも Firebase に依存していません。このことを利用して、 &lt;code&gt;Analytics&lt;/code&gt; モジュールに &lt;code&gt;AnalyticsService&lt;/code&gt; と &lt;code&gt;AnalyticsServiceMock&lt;/code&gt; のみを残して、 &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; を &lt;code&gt;AnalyticsLive&lt;/code&gt; というモジュールに分けることにします。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// Package.swift

let package = Package(
    // ...
    targets: [
        // ...
        .target(
            name: &amp;quot;Analytics&amp;quot;,
&lt;span class=&quot;synSpecial&quot;&gt;-           dependencies: [.product(name: &amp;quot;FirebaseAnalytics&amp;quot;, package: &amp;quot;firebase-ios-sdk&amp;quot;)]&lt;/span&gt;
        ),
&lt;span class=&quot;synIdentifier&quot;&gt;+       .target(&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           name: &amp;quot;AnalyticsLive&amp;quot;,&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           dependencies: [&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+               &amp;quot;Analytics&amp;quot;,&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+               .product(name: &amp;quot;FirebaseAnalytics&amp;quot;, package: &amp;quot;firebase-ios-sdk&amp;quot;),&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           ]&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       ),&lt;/span&gt;
    ]
)
&lt;/pre&gt;




&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// Analytics/AnalyticsService.swift

&lt;span class=&quot;synSpecial&quot;&gt;- import FirebaseAnalytics&lt;/span&gt;

public protocol AnalyticsService {
    func log(event: String)
}

&lt;span class=&quot;synSpecial&quot;&gt;- public final class AnalyticsServiceLive: AnalyticsService {&lt;/span&gt;
&lt;span class=&quot;synSpecial&quot;&gt;-     public init() {}&lt;/span&gt;
&lt;span class=&quot;synSpecial&quot;&gt;- &lt;/span&gt;
&lt;span class=&quot;synSpecial&quot;&gt;-     public func log(event: String) {&lt;/span&gt;
&lt;span class=&quot;synSpecial&quot;&gt;-         FirebaseAnalytics.Analytics.logEvent(event, parameters: nil)&lt;/span&gt;
&lt;span class=&quot;synSpecial&quot;&gt;-     }&lt;/span&gt;
&lt;span class=&quot;synSpecial&quot;&gt;- }&lt;/span&gt;

// ...
&lt;/pre&gt;




&lt;pre class=&quot;code lang-swift&quot; data-lang=&quot;swift&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;// AnalyticsLive/AnalyticsServiceLive.swfit&lt;/span&gt;

&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; Analytics
&lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; FirebaseAnalytics

&lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;AnalyticsServiceLive&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;AnalyticsService&lt;/span&gt; {
    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;init&lt;/span&gt;() {}

    &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;log&lt;/span&gt;(event&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;String&lt;/span&gt;) {
        FirebaseAnalytics.Analytics.logEvent(event, parameters&lt;span class=&quot;synSpecial&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;nil&lt;/span&gt;)
    }
}
&lt;/pre&gt;


&lt;p&gt;以上の作業により、 &lt;code&gt;CounterFeature&lt;/code&gt; モジュールから &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; が見えなくなったため、 &lt;code&gt;CounterScreen&lt;/code&gt; にて初期化することができなくなります。そのため、 &lt;code&gt;AnalyticsService&lt;/code&gt; を外部から DI してもらうことにします。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;public struct CounterScreen: View {
&lt;span class=&quot;synSpecial&quot;&gt;-   @StateObject private var viewModel: CounterViewModel = .init(analyticsService: AnalyticsServiceLive())&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   @StateObject private var viewModel: CounterViewModel&lt;/span&gt;

&lt;span class=&quot;synSpecial&quot;&gt;-   public init() {}&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   public init(analyticsService: any AnalyticsService) {&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+       self._viewModel = .init(wrappedValue: .init(analyticsService: analyticsService))&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   }&lt;/span&gt;

    public var body: some View {
        // ...
    }
}

&lt;span class=&quot;synComment&quot;&gt;#Preview {&lt;/span&gt;
&lt;span class=&quot;synSpecial&quot;&gt;-   CounterScreen()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+   CounterScreen(analyticsService: AnalyticsServiceMock())&lt;/span&gt;
}
&lt;/pre&gt;


&lt;p&gt;ここまでの変更により、モジュール間の依存関係が以下のようになりました。&lt;/p&gt;

&lt;pre class=&quot;code mermaid&quot; data-lang=&quot;mermaid&quot; data-unlink&gt;graph LR
    classDef default font-family:monospace;
    CounterFeature --&amp;gt; Analytics
    AnalyticsLive --&amp;gt; Firebase&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;CounterFeature&lt;/code&gt; と Firebase の間には間接的な依存関係もなくなっているため、 &lt;code&gt;CounterFeature&lt;/code&gt; のテストやプレビューのために Firebase のビルドが走らなくなっています。&lt;/p&gt;

&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209041206.png&quot; width=&quot;1200&quot; height=&quot;677&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Analytics&lt;/code&gt; のようなインターフェースモジュールはその名の通りインターフェースのみを持ち実装を含みません。そのためアプリの機能が増えていっても大きくなったりライブラリに依存したりすることがなく、ビルドが軽いままでいられるという特徴を持っています。 Feature モジュールからインターフェースモジュールにのみ依存することで、アプリ全体のサイズが大きくなっても、テストやプレビューは軽いまま Feature モジュールの開発を効率よく続けていくことができます。&lt;/p&gt;

&lt;p&gt;注意点として、すべてのライブラリに対してインターフェースモジュールを切ることができるわけではありません。例えば、 &lt;a href=&quot;https://github.com/pointfreeco/swift-composable-architecture&quot;&gt;pointfreeco/swift-composable-architecture&lt;/a&gt; や &lt;a href=&quot;https://github.com/ReactiveX/RxSwift&quot;&gt;ReactiveX/RxSwift&lt;/a&gt; など Feature モジュールのロジックを実行すること自体に必要なライブラリには直接的に依存せざるを得ないでしょう。
また、インターフェースモジュールを切ることができる場合でも必ず切ったほうがよいというわけでもありません。利用したいライブラリのビルドが軽かったり、特定の Feature モジュール&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A4%AB%A4%E9%A4%B7&quot;&gt;からし&lt;/a&gt;か使われないような場合には、インターフェースモジュールを切るメリットが相対的に小さくなるため、ライブラリに直接依存してしまった方がアプリ全体の開発効率が高苦なるかもしれません。新しくモジュールを切るということはそれ自体がコストなので、メリットとデメリットのバランスを見てどうするか決めていくのがよいと思っています。&lt;/p&gt;

&lt;h2 id=&quot;依存の実体を-DI-する&quot;&gt;依存の実体を DI する&lt;/h2&gt;

&lt;p&gt;この時点で &lt;code&gt;CounterFeature&lt;/code&gt; 単体ではビルドできますが、アプリ全体ではビルドが通らない状態になっています。 &lt;code&gt;CounterScreen&lt;/code&gt; に &lt;code&gt;AnalyticsService&lt;/code&gt; が渡されていないためです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CounterFeature&lt;/code&gt; と Firebase に依存関係はなくなりましたが、アプリの実行中はもちろん実際に Firebase に向けてイベントを送りたいです。このような要件は一般に、よりアプリケーションの main に近い側のモジュールから依存の実体を Feature モジュールに DI することにより実現できます。今回のカウンターアプリにおいては、 &lt;code&gt;SampleApp&lt;/code&gt; から &lt;code&gt;CounterFeature&lt;/code&gt; に &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; を渡してあげます。&lt;/p&gt;

&lt;p&gt;そのために &lt;code&gt;AnalyticsLive&lt;/code&gt; をライブラリとして書き出して、 &lt;code&gt;SampleApp&lt;/code&gt; にリンクします。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// Package.swift

let package = Package(
    // ...
    products: [
        .library(name: &amp;quot;CounterFeature&amp;quot;, targets: [&amp;quot;CounterFeature&amp;quot;]),
&lt;span class=&quot;synIdentifier&quot;&gt;+       .library(name: &amp;quot;AnalyticsLive&amp;quot;, targets: [&amp;quot;AnalyticsLive&amp;quot;]),&lt;/span&gt;
    ],
    // ...
}
&lt;/pre&gt;


&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209145843.png&quot; width=&quot;1200&quot; height=&quot;287&quot; loading=&quot;lazy&quot; title=&quot;&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;その上で、 &lt;code&gt;SampleApp&lt;/code&gt; を以下のように変更することでアプリのビルドが通り、 Firebase にイベントを送れるようになります。&lt;/p&gt;

&lt;pre class=&quot;code lang-diff&quot; data-lang=&quot;diff&quot; data-unlink&gt;// SampleApp.swift

import SwiftUI
&lt;span class=&quot;synIdentifier&quot;&gt;+ import AnalyticsLive&lt;/span&gt;
import CounterFeature
import FirebaseCore
import FirebaseAnalytics

// ...

&lt;span class=&quot;synStatement&quot;&gt;@main&lt;/span&gt;
struct SampleApp: App {
    // ...
    
    var body: some Scene {
        WindowGroup {
&lt;span class=&quot;synSpecial&quot;&gt;-           CounterScreen()&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;+           CounterScreen(analyticsService: AnalyticsServiceLive())&lt;/span&gt;
        }
    }
}
&lt;/pre&gt;


&lt;p&gt;アプリ全体の最終的なモジュール間の依存関係は以下です。 &lt;code&gt;CounterFeature&lt;/code&gt; モジュールは依存のインターフェースしか知らず、そのインターフェースを満たす依存の実体を &lt;code&gt;SampleApp&lt;/code&gt; から渡してもらって使うだけになっています。&lt;/p&gt;

&lt;pre class=&quot;code mermaid&quot; data-lang=&quot;mermaid&quot; data-unlink&gt;graph LR
    classDef default font-family:monospace;
    CounterFeature --&amp;gt; AnalyticsService
    AnalyticsServiceLive --&amp;gt; Firebase
    SampleApp --&amp;gt; AnalyticsServiceLive
    SampleApp --&amp;gt; CounterFeature&lt;/pre&gt;


&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;アプリの成長とともに、アプリ全体のビルド時間が長くなっていくことは避けがたいです。しかし、アプリをモジュール分割したり、インターフェースモジュールを導入したりすることで、テストやプレビューから高速なフィードバックを受けながら Feature モジュールを開発していくことができます。&lt;/p&gt;

&lt;p&gt;もちろんこの記事のサンプルアプリは本当にシンプルなものなので、実際のアプリでもこの記事のようにことがうまく運ぶとは限りません。しかし、適切な場面でモジュール化やインターフェースモジュールの導入をすることでアプリの開発体験を向上させることができるのではないかと思います。&lt;/p&gt;

&lt;h2 id=&quot;記事で触れられなかったモジュール化のメリット&quot;&gt;記事で触れられなかったモジュール化のメリット&lt;/h2&gt;

&lt;p&gt;この記事ではモジュール化やインターフェースモジュールのメリットとして Feature モジュールのテストやプレビューの高速化について見てきました。&lt;/p&gt;

&lt;p&gt;これに加えて、インターフェースモジュールには例えば &lt;a href=&quot;https://www.runway.team/blog/how-to-improve-ios-build-times-with-modularization&quot;&gt;how-to-improve-ios-build-times-with-modularization&lt;/a&gt; に書かれているようにアプリ全体の差分ビルドを効率化するというメリットもあります。あわせて読んでいただけるとよさそうです。&lt;/p&gt;

&lt;p&gt;また、 Feature モジュールに限らずモデル層の&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8&quot;&gt;コンポーネント&lt;/a&gt;についても、モジュール化により開発効率を向上させることができます。例えば、サンプルアプリの &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; は現状テストを書くほどのロジックがありませんが、もしロジックが複雑化した場合には &lt;code&gt;AnalyticsServiceLiveTests&lt;/code&gt; のようなテストターゲットを追加することで&lt;a class=&quot;keyword&quot; href=&quot;https://d.hatena.ne.jp/keyword/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8&quot;&gt;ユニットテスト&lt;/a&gt;が可能です。
&lt;code&gt;AnalyticsServiceLiveTests&lt;/code&gt; の実行のためにはアプリ全体ではなく &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; をビルドすればよいため、モジュール化によりテストの実行が効率化できます。 &lt;code&gt;AnalyticsServiceLive&lt;/code&gt; は Firebase に依存してしまっていますが、一般にモデル層のモジュールは Feature モジュールよりも依存が少なくなるため、テストはとても高速に実行できることが多いです。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.runway.team%2Fblog%2Fhow-to-improve-ios-build-times-with-modularization&quot; title=&quot;How to improve iOS build times with modularization | Runway&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://www.runway.team/blog/how-to-improve-ios-build-times-with-modularization&quot;&gt;www.runway.team&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.pointfree.co%2Fcollections%2Fdependencies%2Fdesigning-dependencies%2Fep111-designing-dependencies-modularization&quot; title=&quot;Episode #111: Designing Dependencies: Modularization&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://www.pointfree.co/collections/dependencies/designing-dependencies/ep111-designing-dependencies-modularization&quot;&gt;www.pointfree.co&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fqiita.com%2FYusukeHosonuma%2Fitems%2F77bbb962e8ec4d36cbea&quot; title=&quot;【Swift】Bastard Injection の問題点、あるいは依存性逆転の原則について。または needle というDIコンテナの紹介。 - Qiita&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://qiita.com/YusukeHosonuma/items/77bbb962e8ec4d36cbea&quot;&gt;qiita.com&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
</content>        
        <link rel="enclosure" href="https://cdn-ak.f.st-hatena.com/images/fotolife/m/maiyama4/20231209/20231209034204.png" type="image/png" length="0" />

        <author>
            <name>maiyama4</name>
        </author>
    </entry>
    
  
</feed>
